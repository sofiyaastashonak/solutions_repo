{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Introduction Have you ever wondered how a soccer ball follows a curved path when kicked? Or how rockets and missiles follow precise trajectories? This is all because of projectile motion ! In this report, i will explore how the range of a projectile depends on the launch angle and break it down step by step. 2. What is Projectile Motion? Projectile motion happens when an object is launched into the air and moves under the influence of gravity . The motion can be split into two parts: Horizontal motion : The object moves forward with a constant speed. Vertical motion : The object moves up and down due to gravity. To understand projectile motion better, let's derive some important equations. 3. Key Equations of Motion 3.1 Breaking Motion into Components If an object is launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) , we can break this velocity into: Horizontal velocity : \\(v_x=v_0\\cos\\theta\\) Vertical velocity : \\(v_y=v_0\\sin\\theta\\) Since gravity only affects vertical motion , the horizontal velocity stays constant . 3.2 Equations for Position and Velocity Using basic physics formulas, we get: 1\ufe0f\u20e3 Horizontal position (distance traveled in time \\(t\\) ) : \\[x=v_0\\cos\\theta\\cdot t\\] 2\ufe0f\u20e3 Vertical position (height at time \\(t\\) ) : \\[y=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\] 3\ufe0f\u20e3 Velocity in the horizontal direction (always constant): \\[v_x=v_0\\cos\\theta\\] 4\ufe0f\u20e3 Velocity in the vertical direction (changes due to gravity): \\[v_y=v_0\\sin\\theta-gt\\] 3.3 Finding Special Points Now let's look at some important moments in the projectile\u2019s motion. \u2714\ufe0f Time of Flight (How long the object stays in the air): \\[t_f=\\frac{2v_0\\sin\\theta}{g}\\] \u2714\ufe0f Maximum Height (The highest point the object reaches): \\[H=\\frac{(v_0\\sin\\theta)^2}{2g}\\] \u2714\ufe0f Range (Total Distance the Object Travels Before Hitting the Ground) : \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] Interesting Fact: The projectile travels the longest distance when launched at 45\u00b0 because \\(\\sin(2\\theta)\\) is largest at this angle. Why Does a Projectile Travel the Farthest at 45\u00b0? \ud83d\udd39 The Optimal Angle: 45\u00b0 At 45\u00b0 , the velocity is split equally between horizontal and vertical directions, creating the perfect balance between airtime and forward motion . Mathematically, the range of a projectile is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] where: \\(R\\) = range of the projectile, \\(v_0\\) = initial velocity, \\(\\theta\\) = launch angle, \\(g\\) = acceleration due to gravity. The function \\(\\sin 2\\theta\\) reaches its maximum value when: \\[ 2\\theta = 90^\\circ \\quad \\Rightarrow \\quad \\theta = 45^\\circ \\] Thus, a projectile launched at 45\u00b0 travels the farthest distance because it achieves the optimal balance between horizontal and vertical motion. 4. Family of Solutions The equations above describe a family of solutions depending on different values of: Launch speed ( \\(v_0\\) ) : Faster projectiles travel farther and higher. The initial speed determines the kinetic energy and range: \\(v_0 = 15\\) m/s \u2192 short trajectory \\(v_0 = 20\\) m/s \u2192 medium \\(v_0 = 25\\) m/s \u2192 long and high trajectory Launch angle ( \\(\\theta\\) ) : Determines the shape of the trajectory. The launch angle determines how the initial speed is split into horizontal and vertical components: Low angle (30\u00b0) : Strong horizontal motion, short airtime \u2192 low flat trajectory. Optimal angle (45\u00b0) : Perfect balance of height and range \u2192 maximum horizontal distance. High angle (60\u00b0) : High arc, longer airtime but shorter range. Gravity ( \\(g\\) ) : Affects how quickly the projectile falls. The gravitational pull affects both maximum height and time of flight . Planet \ud83c\udf0d Gravity \\(g\\) (m/s\u00b2) Earth 9.81 Mars 3.71 Moon 1.62 On the Moon , projectiles rise higher and stay in the air much longer. On Mars , the behavior is intermediate between Moon and Earth. Initial height ( \\(h\\) ) : Changes the total flight time and range. Initial height \\(h\\) changes how far the projectile travels before hitting the ground . \\(h = 0\\) m : Launch from ground. \\(h = 10\\) m : Launch from a platform. \\(h = 20\\) m : Launch from a rooftop/mountain. By adjusting these values, we get different possible trajectories , from low and fast motions (like bullets) to high and slow ones (like thrown balls). 5. Limitations of the Idealized Model The equations we used assume an ideal world where: \u274c No air resistance : In reality, air slows down projectiles. \u274c Flat ground assumption : The model assumes the projectile lands at the same height. \u274c Constant gravity ( \\(g\\) ) : Gravity actually changes with altitude. Because of these assumptions, our equations give approximate results in the real world. 6. Extending the Model: Real-World Effects To make the model more realistic , we can add: \u2705 Air Resistance (Drag Force) The force slows the projectile down. The drag force is proportional to the square of the velocity: \\[F_d=\\frac{1}{2} C_d \\rho A v^2\\] where \\(C_d\\) is the drag coefficient, \\(\\rho\\) is air density, and \\(A\\) is the cross-sectional area. \u2705 Wind Effects A tailwind increases range, while a headwind decreases it. A tailwind adds to horizontal velocity \u2192 increases range. A headwind subtracts \u2192 reduces distance. Crosswind : affects side motion (not modeled here but relevant in real life). \u2705 Launch Altitude At high altitudes, air resistance is lower, and gravity is weaker, so objects travel farther . \u2705 Rotation of the Earth (Coriolis Effect) Important for long-range artillery and missiles. On a rotating Earth, especially at large scales (e.g., missiles, satellites), the Coriolis force causes the projectile to deviate: - In the Northern Hemisphere: rightward deflection. - In the Southern Hemisphere: leftward deflection. 7. Real-World Applications \ud83c\udf0d Projectile motion is not just for physics classes! It applies to: Sports : How football players kick the ball at different angles. Military : How missiles and bullets are fired for maximum range. Space Exploration : How rockets are launched at precise angles. Phython Implimentation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravity (m/s^2) angles = [45] # Fixed launch angle velocities = [30, 40, 50] # Different initial velocities (m/s) colors = ['red', 'purple', 'green'] # Colors for different trajectories plt.figure(figsize=(8, 5)) # Loop through each velocity and plot trajectory for v0, color in zip(velocities, colors): t_flight = 2 * v0 * np.sin(np.radians(angles[0])) / g # Time of flight t = np.linspace(0, t_flight, num=100) # Time intervals x = v0 * np.cos(np.radians(angles[0])) * t # Horizontal distance y = v0 * np.sin(np.radians(angles[0])) * t - 0.5 * g * t**2 # Vertical distance plt.plot(x, y, label=f'{v0} m/s', color=color) # Labels and grid plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion at 45\u00b0 with Different Initial Velocities\") plt.legend() plt.grid() plt.show() Plot colablink 8. Conclusion Now we u understand the key ideas behind projectile motion: It has both horizontal and vertical movement . Gravity only affects the vertical motion . The best angle for the longest range is 45\u00b0 . The initial speed, angle, and gravity all affect the motion . The real world includes air resistance, wind, and altitude effects . Understanding these principles helps in designing better sports strategies, video game physics, and even launching space missions!","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Have you ever wondered how a soccer ball follows a curved path when kicked? Or how rockets and missiles follow precise trajectories? This is all because of projectile motion ! In this report, i will explore how the range of a projectile depends on the launch angle and break it down step by step.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-what-is-projectile-motion","text":"Projectile motion happens when an object is launched into the air and moves under the influence of gravity . The motion can be split into two parts: Horizontal motion : The object moves forward with a constant speed. Vertical motion : The object moves up and down due to gravity. To understand projectile motion better, let's derive some important equations.","title":"2. What is Projectile Motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-key-equations-of-motion","text":"","title":"3. Key Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-breaking-motion-into-components","text":"If an object is launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) , we can break this velocity into: Horizontal velocity : \\(v_x=v_0\\cos\\theta\\) Vertical velocity : \\(v_y=v_0\\sin\\theta\\) Since gravity only affects vertical motion , the horizontal velocity stays constant .","title":"3.1 Breaking Motion into Components"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-equations-for-position-and-velocity","text":"Using basic physics formulas, we get: 1\ufe0f\u20e3 Horizontal position (distance traveled in time \\(t\\) ) : \\[x=v_0\\cos\\theta\\cdot t\\] 2\ufe0f\u20e3 Vertical position (height at time \\(t\\) ) : \\[y=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\] 3\ufe0f\u20e3 Velocity in the horizontal direction (always constant): \\[v_x=v_0\\cos\\theta\\] 4\ufe0f\u20e3 Velocity in the vertical direction (changes due to gravity): \\[v_y=v_0\\sin\\theta-gt\\]","title":"3.2 Equations for Position and Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-finding-special-points","text":"Now let's look at some important moments in the projectile\u2019s motion. \u2714\ufe0f Time of Flight (How long the object stays in the air): \\[t_f=\\frac{2v_0\\sin\\theta}{g}\\] \u2714\ufe0f Maximum Height (The highest point the object reaches): \\[H=\\frac{(v_0\\sin\\theta)^2}{2g}\\] \u2714\ufe0f Range (Total Distance the Object Travels Before Hitting the Ground) : \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\]","title":"3.3 Finding Special Points"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#interesting-fact-the-projectile-travels-the-longest-distance-when-launched-at-45-because-sin2theta-is-largest-at-this-angle","text":"","title":"Interesting Fact: The projectile travels the longest distance when launched at 45\u00b0 because \\(\\sin(2\\theta)\\) is largest at this angle."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#why-does-a-projectile-travel-the-farthest-at-45","text":"","title":"Why Does a Projectile Travel the Farthest at 45\u00b0?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-optimal-angle-45","text":"At 45\u00b0 , the velocity is split equally between horizontal and vertical directions, creating the perfect balance between airtime and forward motion . Mathematically, the range of a projectile is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] where: \\(R\\) = range of the projectile, \\(v_0\\) = initial velocity, \\(\\theta\\) = launch angle, \\(g\\) = acceleration due to gravity. The function \\(\\sin 2\\theta\\) reaches its maximum value when: \\[ 2\\theta = 90^\\circ \\quad \\Rightarrow \\quad \\theta = 45^\\circ \\] Thus, a projectile launched at 45\u00b0 travels the farthest distance because it achieves the optimal balance between horizontal and vertical motion.","title":"\ud83d\udd39 The Optimal Angle: 45\u00b0"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-family-of-solutions","text":"The equations above describe a family of solutions depending on different values of: Launch speed ( \\(v_0\\) ) : Faster projectiles travel farther and higher. The initial speed determines the kinetic energy and range: \\(v_0 = 15\\) m/s \u2192 short trajectory \\(v_0 = 20\\) m/s \u2192 medium \\(v_0 = 25\\) m/s \u2192 long and high trajectory Launch angle ( \\(\\theta\\) ) : Determines the shape of the trajectory. The launch angle determines how the initial speed is split into horizontal and vertical components: Low angle (30\u00b0) : Strong horizontal motion, short airtime \u2192 low flat trajectory. Optimal angle (45\u00b0) : Perfect balance of height and range \u2192 maximum horizontal distance. High angle (60\u00b0) : High arc, longer airtime but shorter range. Gravity ( \\(g\\) ) : Affects how quickly the projectile falls. The gravitational pull affects both maximum height and time of flight . Planet \ud83c\udf0d Gravity \\(g\\) (m/s\u00b2) Earth 9.81 Mars 3.71 Moon 1.62 On the Moon , projectiles rise higher and stay in the air much longer. On Mars , the behavior is intermediate between Moon and Earth. Initial height ( \\(h\\) ) : Changes the total flight time and range. Initial height \\(h\\) changes how far the projectile travels before hitting the ground . \\(h = 0\\) m : Launch from ground. \\(h = 10\\) m : Launch from a platform. \\(h = 20\\) m : Launch from a rooftop/mountain. By adjusting these values, we get different possible trajectories , from low and fast motions (like bullets) to high and slow ones (like thrown balls).","title":"4. Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-of-the-idealized-model","text":"The equations we used assume an ideal world where: \u274c No air resistance : In reality, air slows down projectiles. \u274c Flat ground assumption : The model assumes the projectile lands at the same height. \u274c Constant gravity ( \\(g\\) ) : Gravity actually changes with altitude. Because of these assumptions, our equations give approximate results in the real world.","title":"5. Limitations of the Idealized Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-extending-the-model-real-world-effects","text":"To make the model more realistic , we can add: \u2705 Air Resistance (Drag Force) The force slows the projectile down. The drag force is proportional to the square of the velocity: \\[F_d=\\frac{1}{2} C_d \\rho A v^2\\] where \\(C_d\\) is the drag coefficient, \\(\\rho\\) is air density, and \\(A\\) is the cross-sectional area. \u2705 Wind Effects A tailwind increases range, while a headwind decreases it. A tailwind adds to horizontal velocity \u2192 increases range. A headwind subtracts \u2192 reduces distance. Crosswind : affects side motion (not modeled here but relevant in real life). \u2705 Launch Altitude At high altitudes, air resistance is lower, and gravity is weaker, so objects travel farther . \u2705 Rotation of the Earth (Coriolis Effect) Important for long-range artillery and missiles. On a rotating Earth, especially at large scales (e.g., missiles, satellites), the Coriolis force causes the projectile to deviate: - In the Northern Hemisphere: rightward deflection. - In the Southern Hemisphere: leftward deflection.","title":"6. Extending the Model: Real-World Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-real-world-applications","text":"Projectile motion is not just for physics classes! It applies to: Sports : How football players kick the ball at different angles. Military : How missiles and bullets are fired for maximum range. Space Exploration : How rockets are launched at precise angles.","title":"7. Real-World Applications \ud83c\udf0d"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#phython-implimentation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravity (m/s^2) angles = [45] # Fixed launch angle velocities = [30, 40, 50] # Different initial velocities (m/s) colors = ['red', 'purple', 'green'] # Colors for different trajectories plt.figure(figsize=(8, 5)) # Loop through each velocity and plot trajectory for v0, color in zip(velocities, colors): t_flight = 2 * v0 * np.sin(np.radians(angles[0])) / g # Time of flight t = np.linspace(0, t_flight, num=100) # Time intervals x = v0 * np.cos(np.radians(angles[0])) * t # Horizontal distance y = v0 * np.sin(np.radians(angles[0])) * t - 0.5 * g * t**2 # Vertical distance plt.plot(x, y, label=f'{v0} m/s', color=color) # Labels and grid plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion at 45\u00b0 with Different Initial Velocities\") plt.legend() plt.grid() plt.show()","title":"Phython Implimentation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot","text":"","title":"Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colablink","text":"","title":"colablink"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#8-conclusion","text":"Now we u understand the key ideas behind projectile motion: It has both horizontal and vertical movement . Gravity only affects the vertical motion . The best angle for the longest range is 45\u00b0 . The initial speed, angle, and gravity all affect the motion . The real world includes air resistance, wind, and altitude effects . Understanding these principles helps in designing better sports strategies, video game physics, and even launching space missions!","title":"8. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is a system that exhibits a wide range of behaviors, from simple periodic oscillations to chaotic motion . The equation governing its motion is: \\[\\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2\\sin\\theta = A\\cos(\\omega t)\\] where: - \\(\\theta\\) = angular displacement (radians) - \\(\\gamma\\) = damping coefficient (determines energy loss over time) - \\(\\omega_0\\) = natural frequency of the pendulum, given by: \\[omega_0^2=frac{g}{L}\\] where \\(g\\) is the acceleration due to gravity and \\(L\\) is the pendulum length - \\(A\\) = amplitude of the external driving force - \\(\\omega\\) = driving frequency of the external force 1.1 Small-Angle Approximation For small oscillations , we approximate: \\[\\sin\\theta \\approx \\theta\\] Substituting this approximation into the equation of motion simplifies it to: \\[\\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2\\theta = A\\cos(\\omega t)\\] This is now a linear differential equation , which can be solved analytically. The general solution consists of two parts: Homogeneous solution (natural motion of the damped pendulum): \\[\\theta_h(t) = e^{-\\gamma t/2} (C_1\\cos(\\omega_d t) + C_2\\sin(\\omega_d t))\\] where the damped frequency is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}}\\] Particular solution (response to the external force): \\[\\theta_p(t) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2\\omega^2}} \\cos(\\omega t - \\phi)\\] where the phase shift \\(\\phi\\) is given by: \\[\\tan\\phi = \\frac{\\gamma\\omega}{\\omega_0^2 - \\omega^2}\\] The total solution is: \\[\\theta(t) = \\theta_h(t) + \\theta_p(t)\\] 1.2 Resonance Condition Resonance occurs when the driving frequency matches the system\u2019s natural frequency: \\[\\omega \\approx \\omega_0\\] At resonance, the amplitude of oscillations increases significantly , which can lead to extreme behaviors in real-world systems (e.g., structural failures in bridges or mechanical components). 1.3 Energy Exchange in the System The energy in the forced damped pendulum consists of: Kinetic energy : \\[KE = \\frac{1}{2} m L^2 \\dot{\\theta}^2\\] Potential energy : \\[PE = mgL(1 - \\cos\\theta)\\] Total energy : \\[E = KE + PE\\] Over time, damping ( \\(\\gamma\\) ) removes energy from the system, while the external force ( \\(A\\cos(\\omega t)\\) ) injects energy. The balance between these competing effects determines the system\u2019s long-term behavior. 2. Analysis of Dynamics \ud83d\udcca 2.1 Influence of System Parameters The behavior of the pendulum depends on: - Damping \\(\\gamma\\) : - High damping: Oscillations die out quickly. - Low damping: Sustained oscillations, possibly chaotic motion. - Driving force amplitude \\(A\\) : - Small \\(A\\) : Regular oscillations. - Large \\(A\\) : Large amplitude, possibly chaotic motion. - Driving frequency \\(\\omega\\) : - Near \\(\\omega_0\\) : Resonance can occur. - Far from \\(\\omega_0\\) : No significant amplification. 2.2 Types of Motion Observed Depending on the parameter values, the system exhibits: \u2705 Periodic motion (stable oscillations) \u2705 Resonance (sharp amplitude increase at specific frequencies) \u2705 Quasi-periodic motion (oscillations with two incommensurate frequencies) \u2705 Chaotic motion (unpredictable behavior due to sensitivity to initial conditions) 3. Practical Applications \ud83c\udf0d The forced damped pendulum model is useful in: \u2705 Energy harvesting (pendulum-based generators converting mechanical energy into electricity) \u2705 Suspension bridge analysis (to prevent resonance-induced collapses like Tacoma Narrows Bridge) \u2705 Electrical circuits (driven RLC circuits behave analogously) \u2705 Biomechanics (understanding human walking and balance) 4. Simulation and Visualization of Pendulum Dynamics To better understand how different physical effects influence a pendulum's behavior, we simulate four distinct scenarios using numerical integration of the equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A\\cos(\\omega t)\\] where: - \\(b\\) is the damping coefficient, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. Each scenario is visualized with: - \u03b8(t) \u2014 how the angle changes over time - Phase diagram (\u03b8, \u03c9) \u2014 angular displacement vs angular velocity 4.1 \ud83d\udfe2 Simple Undamped Pendulum (No Damping, No Forcing) Parameters: \\(b = 0\\) , \\(A = 0\\) The pendulum swings indefinitely with no energy loss. The motion is periodic and predictable. Expected plots: - The angle \\(\\theta(t)\\) oscillates sinusoidally. The phase diagram forms a closed ellipse, showing conservation of energy. 4.2 \ud83d\udd35 Damped Pendulum (With Friction, No External Force) Parameters: \\(b > 0\\) , \\(A = 0\\) The pendulum gradually loses energy due to damping. Oscillations decay over time until the system comes to rest. Expected plots: - \\(\\theta(t)\\) decreases exponentially and eventually stops. The phase diagram spirals toward the origin. 4.3 \ud83d\udfe1 Forced Undamped Pendulum (No Friction, External Periodic Force) Parameters: \\(b = 0\\) , \\(A > 0\\) The system is continuously driven by a periodic force. If driving frequency is close to the natural frequency, resonance may occur. Expected plots: - \\(\\theta(t)\\) shows growing oscillations or steady amplitude depending on \\(\\omega\\) . The phase diagram shows a stable closed loop or expanding spiral. 4.4 \ud83d\udd34 Forced Damped Pendulum (With Friction and Driving Force) We examine two interesting cases: (a) Resonance-like Behavior Parameters: \\(b\\) small, \\(A\\) moderate, \\(\\omega \\approx \\omega_0\\) System reaches steady oscillations with large amplitude. (b) Chaotic Motion Parameters: \\(b\\) small, \\(A\\) high, \\(\\omega\\) tuned for chaos Sensitive to initial conditions, unpredictable long-term behavior. Summary of Results These simulations highlight how small changes in damping or forcing can drastically shift the pendulum\u2019s behavior\u2014from regular motion to chaos. The phase diagrams are especially useful in visualizing the transition from order to chaos. Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) # Differential equation def pendulum(t, y, b, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solver wrapper def simulate(b, A, omega, theta0=0.2, omega0_=0, t_max=30): y0 = [theta0, omega0_] t_eval = np.linspace(0, t_max, 3000) sol = solve_ivp(pendulum, [0, t_max], y0, args=(b, A, omega), t_eval=t_eval, rtol=1e-8) return sol.t, sol.y[0], sol.y[1] # Plotting function def plot_pendulum(t, theta, omega, title_prefix, fig_num): plt.figure(fig_num) plt.plot(t, theta) plt.title(f'{title_prefix}: Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid() plt.savefig(f'{title_prefix}_theta_time.png') plt.figure(fig_num + 1) plt.plot(theta, omega) plt.title(f'{title_prefix}: Phase Diagram') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() plt.savefig(f'{title_prefix}_phase.png') # 1. Simple Pendulum (no damping, no forcing) t, th, om = simulate(b=0, A=0, omega=0) plot_pendulum(t, th, om, 'Simple_Pendulum', 1) # 2. Damped Pendulum (damping, no forcing) t, th, om = simulate(b=0.2, A=0, omega=0) plot_pendulum(t, th, om, 'Damped_Pendulum', 3) # 3. Forced Undamped Pendulum (no damping, with driving) t, th, om = simulate(b=0, A=1.2, omega=omega0) plot_pendulum(t, th, om, 'Forced_Undamped', 5) # 4a. Forced Damped Pendulum - Resonance t, th, om = simulate(b=0.1, A=1.2, omega=omega0) plot_pendulum(t, th, om, 'Forced_Damped_Resonance', 7) # 4b. Forced Damped Pendulum - Chaotic (longer sim, more sensitivity) t, th, om = simulate(b=0.2, A=1.5, omega=0.8 * omega0, theta0=1.5, t_max=60) plot_pendulum(t, th, om, 'Forced_Damped_Chaos', 9) --- colablink 5. Conclusion The forced damped pendulum is a powerful model for understanding real-world oscillatory systems. By adjusting damping, forcing, and initial conditions, we can explore periodic, resonant, and chaotic behaviors . Using numerical simulations and phase-space analysis , we can study transitions from simple oscillations to chaos , with applications in engineering, physics, and biomechanics . This report combines theoretical derivations, computational techniques, and real-world applications to provide a deep understanding of the system.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a system that exhibits a wide range of behaviors, from simple periodic oscillations to chaotic motion . The equation governing its motion is: \\[\\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2\\sin\\theta = A\\cos(\\omega t)\\] where: - \\(\\theta\\) = angular displacement (radians) - \\(\\gamma\\) = damping coefficient (determines energy loss over time) - \\(\\omega_0\\) = natural frequency of the pendulum, given by: \\[omega_0^2=frac{g}{L}\\] where \\(g\\) is the acceleration due to gravity and \\(L\\) is the pendulum length - \\(A\\) = amplitude of the external driving force - \\(\\omega\\) = driving frequency of the external force","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-small-angle-approximation","text":"For small oscillations , we approximate: \\[\\sin\\theta \\approx \\theta\\] Substituting this approximation into the equation of motion simplifies it to: \\[\\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2\\theta = A\\cos(\\omega t)\\] This is now a linear differential equation , which can be solved analytically. The general solution consists of two parts: Homogeneous solution (natural motion of the damped pendulum): \\[\\theta_h(t) = e^{-\\gamma t/2} (C_1\\cos(\\omega_d t) + C_2\\sin(\\omega_d t))\\] where the damped frequency is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}}\\] Particular solution (response to the external force): \\[\\theta_p(t) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2\\omega^2}} \\cos(\\omega t - \\phi)\\] where the phase shift \\(\\phi\\) is given by: \\[\\tan\\phi = \\frac{\\gamma\\omega}{\\omega_0^2 - \\omega^2}\\] The total solution is: \\[\\theta(t) = \\theta_h(t) + \\theta_p(t)\\]","title":"1.1 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-resonance-condition","text":"Resonance occurs when the driving frequency matches the system\u2019s natural frequency: \\[\\omega \\approx \\omega_0\\] At resonance, the amplitude of oscillations increases significantly , which can lead to extreme behaviors in real-world systems (e.g., structural failures in bridges or mechanical components).","title":"1.2 Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-energy-exchange-in-the-system","text":"The energy in the forced damped pendulum consists of: Kinetic energy : \\[KE = \\frac{1}{2} m L^2 \\dot{\\theta}^2\\] Potential energy : \\[PE = mgL(1 - \\cos\\theta)\\] Total energy : \\[E = KE + PE\\] Over time, damping ( \\(\\gamma\\) ) removes energy from the system, while the external force ( \\(A\\cos(\\omega t)\\) ) injects energy. The balance between these competing effects determines the system\u2019s long-term behavior.","title":"1.3 Energy Exchange in the System"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics \ud83d\udcca"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-influence-of-system-parameters","text":"The behavior of the pendulum depends on: - Damping \\(\\gamma\\) : - High damping: Oscillations die out quickly. - Low damping: Sustained oscillations, possibly chaotic motion. - Driving force amplitude \\(A\\) : - Small \\(A\\) : Regular oscillations. - Large \\(A\\) : Large amplitude, possibly chaotic motion. - Driving frequency \\(\\omega\\) : - Near \\(\\omega_0\\) : Resonance can occur. - Far from \\(\\omega_0\\) : No significant amplification.","title":"2.1 Influence of System Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-types-of-motion-observed","text":"Depending on the parameter values, the system exhibits: \u2705 Periodic motion (stable oscillations) \u2705 Resonance (sharp amplitude increase at specific frequencies) \u2705 Quasi-periodic motion (oscillations with two incommensurate frequencies) \u2705 Chaotic motion (unpredictable behavior due to sensitivity to initial conditions)","title":"2.2 Types of Motion Observed"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model is useful in: \u2705 Energy harvesting (pendulum-based generators converting mechanical energy into electricity) \u2705 Suspension bridge analysis (to prevent resonance-induced collapses like Tacoma Narrows Bridge) \u2705 Electrical circuits (driven RLC circuits behave analogously) \u2705 Biomechanics (understanding human walking and balance)","title":"3. Practical Applications \ud83c\udf0d"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-simulation-and-visualization-of-pendulum-dynamics","text":"To better understand how different physical effects influence a pendulum's behavior, we simulate four distinct scenarios using numerical integration of the equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A\\cos(\\omega t)\\] where: - \\(b\\) is the damping coefficient, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. Each scenario is visualized with: - \u03b8(t) \u2014 how the angle changes over time - Phase diagram (\u03b8, \u03c9) \u2014 angular displacement vs angular velocity","title":"4. Simulation and Visualization of Pendulum Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-simple-undamped-pendulum-no-damping-no-forcing","text":"Parameters: \\(b = 0\\) , \\(A = 0\\) The pendulum swings indefinitely with no energy loss. The motion is periodic and predictable. Expected plots: - The angle \\(\\theta(t)\\) oscillates sinusoidally. The phase diagram forms a closed ellipse, showing conservation of energy.","title":"4.1 \ud83d\udfe2 Simple Undamped Pendulum (No Damping, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-damped-pendulum-with-friction-no-external-force","text":"Parameters: \\(b > 0\\) , \\(A = 0\\) The pendulum gradually loses energy due to damping. Oscillations decay over time until the system comes to rest. Expected plots: - \\(\\theta(t)\\) decreases exponentially and eventually stops. The phase diagram spirals toward the origin.","title":"4.2 \ud83d\udd35 Damped Pendulum (With Friction, No External Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-forced-undamped-pendulum-no-friction-external-periodic-force","text":"Parameters: \\(b = 0\\) , \\(A > 0\\) The system is continuously driven by a periodic force. If driving frequency is close to the natural frequency, resonance may occur. Expected plots: - \\(\\theta(t)\\) shows growing oscillations or steady amplitude depending on \\(\\omega\\) . The phase diagram shows a stable closed loop or expanding spiral.","title":"4.3 \ud83d\udfe1 Forced Undamped Pendulum (No Friction, External Periodic Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#44-forced-damped-pendulum-with-friction-and-driving-force","text":"We examine two interesting cases:","title":"4.4 \ud83d\udd34 Forced Damped Pendulum (With Friction and Driving Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#a-resonance-like-behavior","text":"Parameters: \\(b\\) small, \\(A\\) moderate, \\(\\omega \\approx \\omega_0\\) System reaches steady oscillations with large amplitude.","title":"(a) Resonance-like Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#b-chaotic-motion","text":"Parameters: \\(b\\) small, \\(A\\) high, \\(\\omega\\) tuned for chaos Sensitive to initial conditions, unpredictable long-term behavior.","title":"(b) Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary-of-results","text":"These simulations highlight how small changes in damping or forcing can drastically shift the pendulum\u2019s behavior\u2014from regular motion to chaos. The phase diagrams are especially useful in visualizing the transition from order to chaos. Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) # Differential equation def pendulum(t, y, b, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solver wrapper def simulate(b, A, omega, theta0=0.2, omega0_=0, t_max=30): y0 = [theta0, omega0_] t_eval = np.linspace(0, t_max, 3000) sol = solve_ivp(pendulum, [0, t_max], y0, args=(b, A, omega), t_eval=t_eval, rtol=1e-8) return sol.t, sol.y[0], sol.y[1] # Plotting function def plot_pendulum(t, theta, omega, title_prefix, fig_num): plt.figure(fig_num) plt.plot(t, theta) plt.title(f'{title_prefix}: Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid() plt.savefig(f'{title_prefix}_theta_time.png') plt.figure(fig_num + 1) plt.plot(theta, omega) plt.title(f'{title_prefix}: Phase Diagram') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() plt.savefig(f'{title_prefix}_phase.png') # 1. Simple Pendulum (no damping, no forcing) t, th, om = simulate(b=0, A=0, omega=0) plot_pendulum(t, th, om, 'Simple_Pendulum', 1) # 2. Damped Pendulum (damping, no forcing) t, th, om = simulate(b=0.2, A=0, omega=0) plot_pendulum(t, th, om, 'Damped_Pendulum', 3) # 3. Forced Undamped Pendulum (no damping, with driving) t, th, om = simulate(b=0, A=1.2, omega=omega0) plot_pendulum(t, th, om, 'Forced_Undamped', 5) # 4a. Forced Damped Pendulum - Resonance t, th, om = simulate(b=0.1, A=1.2, omega=omega0) plot_pendulum(t, th, om, 'Forced_Damped_Resonance', 7) # 4b. Forced Damped Pendulum - Chaotic (longer sim, more sensitivity) t, th, om = simulate(b=0.2, A=1.5, omega=0.8 * omega0, theta0=1.5, t_max=60) plot_pendulum(t, th, om, 'Forced_Damped_Chaos', 9) --- colablink","title":"Summary of Results"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-conclusion","text":"The forced damped pendulum is a powerful model for understanding real-world oscillatory systems. By adjusting damping, forcing, and initial conditions, we can explore periodic, resonant, and chaotic behaviors . Using numerical simulations and phase-space analysis , we can study transitions from simple oscillations to chaos , with applications in engineering, physics, and biomechanics . This report combines theoretical derivations, computational techniques, and real-world applications to provide a deep understanding of the system.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Investigating the Orbital Period and Orbital Radius Relationship \u2705 1. Theoretical Foundation \ud83d\udd39 Newton's Law and Circular Motion We begin with Newton's law of universal gravitation : \\[F = \\frac{G M m}{r^2}\\] where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant \\((6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2)\\) , - \\(M\\) is the mass of the central body (e.g. the Sun), - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius. For circular motion, this gravitational force provides the centripetal force: \\[F = \\frac{m v^2}{r}\\] Equating the two expressions: \\[\\frac{G M m}{r^2} = \\frac{m v^2}{r}\\] Canceling \\(m\\) and solving for velocity \\(v\\) : \\[v^2 = \\frac{G M}{r}\\] We now use the relationship between orbital speed and period: \\[v = \\frac{2\\pi r}{T}\\] Substitute into the velocity equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r}\\] Expanding and simplifying: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r}\\] Multiply both sides by \\(r\\) : \\[\\frac{4\\pi^2 r^3}{T^2} = G M\\] Solve for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2}{G M} r^3\\] \u2705 Interpretation This is Kepler\u2019s Third Law for circular orbits: \\[T^2 \\propto r^3\\] This means that the square of the orbital period is proportional to the cube of the orbital radius , for objects orbiting the same central body. \ud83d\udd39 Why This Matters Kepler\u2019s Third Law is crucial in astronomy: It allows astronomers to calculate planetary masses by observing orbital periods and distances. Helps in measuring distances in space , like between planets or satellites. It is used to detect exoplanets by observing the periodic wobble of stars. Although Kepler derived it empirically, Newton\u2019s law of gravitation explains it theoretically. \u2705 2. Real-World Examples \ud83d\udd39 Example: The Moon Orbiting the Earth Orbital radius: \\(r \\approx 384,400\\) km Orbital period: \\(T \\approx 27.3\\) days = \\(2.36 \\times 10^6\\) seconds Check that \\(T^2 \\propto r^3\\) : \\[T^2 = (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12}$$ $$r^3 = (3.844 \\times 10^8)^3 \\approx 5.69 \\times 10^{25}\\] Their ratio is nearly constant, consistent with the law. \ud83d\udd39 Example: Planets in the Solar System Planet Radius (AU) Period (Years) \\(T^2\\) \\(r^3\\) Mercury 0.39 0.24 0.0576 0.0593 Venus 0.72 0.62 0.3844 0.3732 Earth 1.00 1.00 1.0000 1.0000 Mars 1.52 1.88 3.5344 3.5127 Jupiter 5.20 11.86 140.67 140.61 As you can see, \\(T^2 \\approx r^3\\) . Below are real values for several planets in the solar system, expressed in meters and seconds , along with calculated \\(T^2\\) and \\(r^3\\) values: Planet \\(r\\) (m) \\(T\\) (s) \\(T^2\\) (s\u00b2) \\(r^3\\) (m\u00b3) Mercury 5.79\u00d710\u00b9\u2070 7.60\u00d710\u2076 5.78\u00d710\u00b9\u00b3 1.94\u00d710\u00b3\u00b2 Venus 1.08\u00d710\u00b9\u00b9 1.94\u00d710\u2077 3.76\u00d710\u00b9\u2074 1.26\u00d710\u00b3\u00b3 Earth 1.496\u00d710\u00b9\u00b9 3.156\u00d710\u2077 9.96\u00d710\u00b9\u2074 3.35\u00d710\u00b3\u00b3 Mars 2.28\u00d710\u00b9\u00b9 5.93\u00d710\u2077 3.52\u00d710\u00b9\u2075 1.18\u00d710\u00b3\u2074 Jupiter 7.78\u00d710\u00b9\u00b9 3.74\u00d710\u2078 1.40\u00d710\u00b9\u2077 4.71\u00d710\u00b3\u2075 \u2705 These values are used to plot the Kepler\u2019s Third Law relationship in SI units : \\(T^2 = \\dfrac{4 \\pi^2}{G M} r^3\\) \u2705 3. Computational Modeling (Python) \ud83d\udd39 Simulate Orbital Motion and Periods import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_sun = 1.989e30 AU = 1.496e11 radii = np.linspace(0.2, 5, 10) * AU T = 2 * np.pi * np.sqrt(radii**3 / (G * M_sun)) plt.figure(figsize=(7, 5)) plt.plot(radii**3, T**2, 'o-', color='purple', label='Numerical $T^2$ vs $r^3$') plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Simulated: $T^2$ vs $r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() ColabLink \ud83d\udd39 Log-Log Representation \ud83d\udccd Insert this code in a code cell plt.figure(figsize=(7, 5)) plt.plot(np.log10(radii), np.log10(T), 'o-', color='green') plt.xlabel(\"$\\log(r)$\") plt.ylabel(\"$\\log(T)$\") plt.title(\"Log-Log Plot: $T \\propto r^{3/2}$\") plt.grid(True) plt.tight_layout() plt.show() \u2705 4. Estimating Masses from Kepler\u2019s Law \ud83d\udd39 Mass of the Earth from the Moon\u2019s Orbit Given: - \\(r = 3.844 \\times 10^8\\ \\text{m}\\) - \\(T = 2.36 \\times 10^6\\ \\text{s}\\) - \\(G = 6.674 \\times 10^{-11}\\) From: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] Calculation: \\[M = \\frac{4 \\pi^2 (3.844 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24}\\ \\text{kg}\\] \u2705 Result matches known mass of Earth. \ud83d\udd39 Mass of the Sun from Earth\u2019s Orbit Given: - \\(r = 1.496 \\times 10^{11}\\ \\text{m}\\) - \\(T = 3.156 \\times 10^7\\ \\text{s}\\) Using the same formula: \\[M = \\frac{4 \\pi^2 r^3}{G T^2}\\] Calculation: \\[M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.674 \\times 10^{-11} (3.156 \\times 10^7)^2} \\approx 1.99 \\times 10^{30}\\ \\text{kg}\\] \u2705 Again, matches known solar mass. \u2705 5. Further Discussion \ud83d\udd39 Elliptical Orbits Kepler\u2019s 3rd law also holds for elliptical orbits, using the semi-major axis \\(a\\) instead of \\(r\\) : \\[T^2 \\propto a^3\\] Newton generalized Kepler\u2019s laws by deriving them from his law of gravitation. \ud83d\udd39 Beyond Planets Binary stars : Masses inferred via orbital motion. Satellites and probes : Trajectory planning uses this law. Exoplanets : Observed stellar wobble gives period \\(T\\) ; estimate \\(a\\) , then derive mass. \u2705 6. Summary and Deliverables \u2705 6. Conclusion Based on the theoretical analysis and computational modeling, we conclude: \ud83d\udcd0 We derived and confirmed Kepler\u2019s Third Law for circular orbits: \\(T^2 = \\dfrac{4\\pi^2}{GM}r^3\\) \ud83c\udf0d We analyzed real planetary data both in astronomical units and in SI units (meters and seconds). \ud83d\udcca We visualized the relationship between \\(T^2\\) and \\(r^3\\) through: A plot with actual solar system planets, A simulated model based on Kepler\u2019s law, A log-log plot showing the expected slope of \\(\\approx \\tfrac{3}{2}\\) . \ud83d\udcbb Python code was implemented to calculate, simulate, and visualize orbital parameters. \ud83d\udd2c Using Kepler\u2019s law, we accurately estimated: The mass of the Earth based on the Moon\u2019s orbit, The mass of the Sun based on Earth\u2019s orbit. \u2705 All results closely match known physical constants and empirical observations. Therefore, the results strongly validate Kepler\u2019s Third Law both theoretically and experimentally.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#investigating-the-orbital-period-and-orbital-radius-relationship","text":"","title":"Investigating the Orbital Period and Orbital Radius Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"\u2705 1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-and-circular-motion","text":"We begin with Newton's law of universal gravitation : \\[F = \\frac{G M m}{r^2}\\] where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant \\((6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2)\\) , - \\(M\\) is the mass of the central body (e.g. the Sun), - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius. For circular motion, this gravitational force provides the centripetal force: \\[F = \\frac{m v^2}{r}\\] Equating the two expressions: \\[\\frac{G M m}{r^2} = \\frac{m v^2}{r}\\] Canceling \\(m\\) and solving for velocity \\(v\\) : \\[v^2 = \\frac{G M}{r}\\] We now use the relationship between orbital speed and period: \\[v = \\frac{2\\pi r}{T}\\] Substitute into the velocity equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r}\\] Expanding and simplifying: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r}\\] Multiply both sides by \\(r\\) : \\[\\frac{4\\pi^2 r^3}{T^2} = G M\\] Solve for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2}{G M} r^3\\]","title":"\ud83d\udd39 Newton's Law and Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation","text":"This is Kepler\u2019s Third Law for circular orbits: \\[T^2 \\propto r^3\\] This means that the square of the orbital period is proportional to the cube of the orbital radius , for objects orbiting the same central body.","title":"\u2705 Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#why-this-matters","text":"Kepler\u2019s Third Law is crucial in astronomy: It allows astronomers to calculate planetary masses by observing orbital periods and distances. Helps in measuring distances in space , like between planets or satellites. It is used to detect exoplanets by observing the periodic wobble of stars. Although Kepler derived it empirically, Newton\u2019s law of gravitation explains it theoretically.","title":"\ud83d\udd39 Why This Matters"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-examples","text":"","title":"\u2705 2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-the-moon-orbiting-the-earth","text":"Orbital radius: \\(r \\approx 384,400\\) km Orbital period: \\(T \\approx 27.3\\) days = \\(2.36 \\times 10^6\\) seconds Check that \\(T^2 \\propto r^3\\) : \\[T^2 = (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12}$$ $$r^3 = (3.844 \\times 10^8)^3 \\approx 5.69 \\times 10^{25}\\] Their ratio is nearly constant, consistent with the law.","title":"\ud83d\udd39 Example: The Moon Orbiting the Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-planets-in-the-solar-system","text":"Planet Radius (AU) Period (Years) \\(T^2\\) \\(r^3\\) Mercury 0.39 0.24 0.0576 0.0593 Venus 0.72 0.62 0.3844 0.3732 Earth 1.00 1.00 1.0000 1.0000 Mars 1.52 1.88 3.5344 3.5127 Jupiter 5.20 11.86 140.67 140.61 As you can see, \\(T^2 \\approx r^3\\) . Below are real values for several planets in the solar system, expressed in meters and seconds , along with calculated \\(T^2\\) and \\(r^3\\) values: Planet \\(r\\) (m) \\(T\\) (s) \\(T^2\\) (s\u00b2) \\(r^3\\) (m\u00b3) Mercury 5.79\u00d710\u00b9\u2070 7.60\u00d710\u2076 5.78\u00d710\u00b9\u00b3 1.94\u00d710\u00b3\u00b2 Venus 1.08\u00d710\u00b9\u00b9 1.94\u00d710\u2077 3.76\u00d710\u00b9\u2074 1.26\u00d710\u00b3\u00b3 Earth 1.496\u00d710\u00b9\u00b9 3.156\u00d710\u2077 9.96\u00d710\u00b9\u2074 3.35\u00d710\u00b3\u00b3 Mars 2.28\u00d710\u00b9\u00b9 5.93\u00d710\u2077 3.52\u00d710\u00b9\u2075 1.18\u00d710\u00b3\u2074 Jupiter 7.78\u00d710\u00b9\u00b9 3.74\u00d710\u2078 1.40\u00d710\u00b9\u2077 4.71\u00d710\u00b3\u2075 \u2705 These values are used to plot the Kepler\u2019s Third Law relationship in SI units : \\(T^2 = \\dfrac{4 \\pi^2}{G M} r^3\\)","title":"\ud83d\udd39 Example: Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-modeling-python","text":"","title":"\u2705 3. Computational Modeling (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulate-orbital-motion-and-periods","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_sun = 1.989e30 AU = 1.496e11 radii = np.linspace(0.2, 5, 10) * AU T = 2 * np.pi * np.sqrt(radii**3 / (G * M_sun)) plt.figure(figsize=(7, 5)) plt.plot(radii**3, T**2, 'o-', color='purple', label='Numerical $T^2$ vs $r^3$') plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Simulated: $T^2$ vs $r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udd39 Simulate Orbital Motion and Periods"},{"location":"1%20Physics/2%20Gravity/Problem_1/#colablink","text":"","title":"ColabLink"},{"location":"1%20Physics/2%20Gravity/Problem_1/#log-log-representation","text":"\ud83d\udccd Insert this code in a code cell plt.figure(figsize=(7, 5)) plt.plot(np.log10(radii), np.log10(T), 'o-', color='green') plt.xlabel(\"$\\log(r)$\") plt.ylabel(\"$\\log(T)$\") plt.title(\"Log-Log Plot: $T \\propto r^{3/2}$\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udd39 Log-Log Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-estimating-masses-from-keplers-law","text":"","title":"\u2705 4. Estimating Masses from Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-of-the-earth-from-the-moons-orbit","text":"Given: - \\(r = 3.844 \\times 10^8\\ \\text{m}\\) - \\(T = 2.36 \\times 10^6\\ \\text{s}\\) - \\(G = 6.674 \\times 10^{-11}\\) From: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] Calculation: \\[M = \\frac{4 \\pi^2 (3.844 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24}\\ \\text{kg}\\] \u2705 Result matches known mass of Earth.","title":"\ud83d\udd39 Mass of the Earth from the Moon\u2019s Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-of-the-sun-from-earths-orbit","text":"Given: - \\(r = 1.496 \\times 10^{11}\\ \\text{m}\\) - \\(T = 3.156 \\times 10^7\\ \\text{s}\\) Using the same formula: \\[M = \\frac{4 \\pi^2 r^3}{G T^2}\\] Calculation: \\[M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.674 \\times 10^{-11} (3.156 \\times 10^7)^2} \\approx 1.99 \\times 10^{30}\\ \\text{kg}\\] \u2705 Again, matches known solar mass.","title":"\ud83d\udd39 Mass of the Sun from Earth\u2019s Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-further-discussion","text":"","title":"\u2705 5. Further Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#elliptical-orbits","text":"Kepler\u2019s 3rd law also holds for elliptical orbits, using the semi-major axis \\(a\\) instead of \\(r\\) : \\[T^2 \\propto a^3\\] Newton generalized Kepler\u2019s laws by deriving them from his law of gravitation.","title":"\ud83d\udd39 Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#beyond-planets","text":"Binary stars : Masses inferred via orbital motion. Satellites and probes : Trajectory planning uses this law. Exoplanets : Observed stellar wobble gives period \\(T\\) ; estimate \\(a\\) , then derive mass.","title":"\ud83d\udd39 Beyond Planets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-summary-and-deliverables","text":"","title":"\u2705 6. Summary and Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion","text":"Based on the theoretical analysis and computational modeling, we conclude: \ud83d\udcd0 We derived and confirmed Kepler\u2019s Third Law for circular orbits: \\(T^2 = \\dfrac{4\\pi^2}{GM}r^3\\) \ud83c\udf0d We analyzed real planetary data both in astronomical units and in SI units (meters and seconds). \ud83d\udcca We visualized the relationship between \\(T^2\\) and \\(r^3\\) through: A plot with actual solar system planets, A simulated model based on Kepler\u2019s law, A log-log plot showing the expected slope of \\(\\approx \\tfrac{3}{2}\\) . \ud83d\udcbb Python code was implemented to calculate, simulate, and visualize orbital parameters. \ud83d\udd2c Using Kepler\u2019s law, we accurately estimated: The mass of the Earth based on the Moon\u2019s orbit, The mass of the Sun based on Earth\u2019s orbit. \u2705 All results closely match known physical constants and empirical observations. Therefore, the results strongly validate Kepler\u2019s Third Law both theoretically and experimentally.","title":"\u2705 6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities \u2705 1. Motivation The concept of escape velocity is essential to understanding how spacecraft overcome the gravitational pull of celestial bodies. More broadly, physicists define three key thresholds of motion in gravitational fields: First cosmic velocity \u2013 the minimum speed required to maintain a stable circular orbit. Second cosmic velocity \u2013 the minimum speed to break free from a planet\u2019s gravity. Third cosmic velocity \u2013 the minimum speed to escape the gravity of a star system. These thresholds are vital for satellite launches, interplanetary travel, and eventually for leaving the Solar System. \u2705 2. Theoretical Background \ud83d\udd39 First Cosmic Velocity (Orbital Speed) This is the minimum speed required for an object to stay in circular orbit around a body (e.g., a satellite orbiting Earth). It's derived from balancing gravitational and centripetal forces: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\] Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] \ud83d\udd39 Second Cosmic Velocity (Escape Speed) This is the minimum speed needed to escape a celestial body\u2019s gravity entirely (ignoring air resistance). It's derived from energy conservation : Total mechanical energy must be zero: \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] \ud83d\udd39 Third Cosmic Velocity (Interstellar Escape) This is the speed required to escape the gravity of the entire star system , like leaving the Solar System. A spacecraft already in Earth orbit has velocity \\(v_\\text{Earth orbit}\\) around the Sun. We need to increase its total energy to unbind it from the Sun: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r_{\\text{Earth}}}} - v_\\text{Earth orbit} \\] Where: \\(M_{\\odot}\\) is the solar mass, \\(r_{\\text{Earth}}\\) is the orbital radius of Earth, \\(v_\\text{Earth orbit} = \\sqrt{\\frac{G M_{\\odot}}{r}}\\) \u2705 3. Values for Earth Given: \\(G = 6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2\\) \\(M_\\text{Earth} = 5.972 \\times 10^{24}\\ \\text{kg}\\) \\(R_\\text{Earth} = 6.371 \\times 10^6\\ \\text{m}\\) \\(M_\\odot = 1.989 \\times 10^{30}\\ \\text{kg}\\) \\(r_\\text{Earth orbit} = 1.496 \\times 10^{11}\\ \\text{m}\\) \u2714 First cosmic velocity: \\[ v_1 = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91 \\times 10^3\\ \\text{m/s} = 7.91\\ \\text{km/s} \\] \u2714 Second cosmic velocity: \\[ v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.2\\ \\text{km/s} \\] \u2714 Third cosmic velocity: Solar orbital speed of Earth: \\[ v_\\text{Earth orbit} = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{1.496 \\times 10^{11}}} \\approx 29.78\\ \\text{km/s} \\] Solar escape speed: \\[ v_\\text{sun,escape} = \\sqrt{2} \\cdot 29.78 \\approx 42.1\\ \\text{km/s} \\] Then: \\[ v_3 = 42.1 - 29.78 \\approx 12.3\\ \\text{km/s} \\] \u2705 4. Summary Table: Cosmic Velocities for Earth Velocity Type Value (km/s) First Cosmic ( \\(v_1\\) ) 7.91 Second Cosmic ( \\(v_2\\) ) 11.2 Third Cosmic ( \\(v_3\\) ) 12.3 \u2705 5. Comparison: Moon, Mars, Jupiter Body Mass (kg) Radius (m) \\(v_1\\) (km/s) \\(v_2\\) (km/s) Moon \\(7.35 \\times 10^{22}\\) \\(1.74 \\times 10^6\\) 1.68 2.38 Mars \\(6.42 \\times 10^{23}\\) \\(3.39 \\times 10^6\\) 3.55 5.03 Earth \\(5.97 \\times 10^{24}\\) \\(6.37 \\times 10^6\\) 7.91 11.2 Jupiter \\(1.90 \\times 10^{27}\\) \\(6.99 \\times 10^7\\) 42.1 59.5 \u2705 6. Python Visualization: Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Data bodies = ['Moon', 'Mars', 'Earth', 'Jupiter'] v1 = [1.68, 3.55, 7.91, 42.1] v2 = [2.38, 5.03, 11.2, 59.5] x = np.arange(len(bodies)) width = 0.35 plt.figure(figsize=(8,5)) plt.bar(x - width/2, v1, width, label='First Cosmic Velocity (v\u2081)', color='royalblue') plt.bar(x + width/2, v2, width, label='Second Cosmic Velocity (v\u2082)', color='crimson') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.xticks(x, bodies) plt.legend() plt.grid(True, linestyle='--', alpha=0.4) plt.tight_layout() plt.show() ColabLink \u2705 7. Importance in Space Exploration Understanding the three cosmic velocities is essential for planning and executing space missions: First Cosmic Velocity ( \\(v_1\\) ) is the speed required to maintain a stable orbit around a celestial body. It is fundamental for launching satellites into low Earth orbit (LEO) and geostationary orbits. Spacecraft like the International Space Station operate at near this speed. Second Cosmic Velocity ( \\(v_2\\) ) is crucial for planetary missions . It allows spacecraft to escape Earth's gravity and travel to the Moon, Mars, or beyond. Missions like Apollo 11, Curiosity rover, and future human missions to Mars rely on achieving this velocity. Third Cosmic Velocity ( \\(v_3\\) ) marks the threshold for interstellar escape . Spacecraft such as Voyager 1 and Voyager 2 reached or exceeded this speed, enabling them to leave the Solar System. Future deep-space missions will use advanced propulsion systems to approach or surpass this velocity. These velocities define not just the energy requirements but also shape mission design, fuel budgets, launch timing, and trajectory planning. \u2705 8. Applications and Insights \ud83d\ude80 Satellite Deployment : Launch vehicles aim to achieve \\(v_1\\) to insert payloads into orbit. Different types of orbits (LEO, MEO, GEO) have slightly different orbital speeds. \ud83c\udf0d Planetary Transfer : To send a probe to Mars or Venus, a spacecraft must achieve \\(v_2\\) to escape Earth\u2019s gravity, and then follow a Hohmann transfer orbit to reach the target. \ud83c\udf0c Interstellar Probes : Voyager 1 and 2 required gravitational assists to reach \\(v_3\\) and leave the Solar System. Future missions, such as the Interstellar Probe Concept , are being designed with these speeds in mind. \u2696\ufe0f Energy Considerations : Each step from \\(v_1\\) to \\(v_3\\) represents an exponential increase in energy. The formula for kinetic energy, \\(E = \\frac{1}{2}mv^2\\) , shows that small increases in speed lead to significantly higher energy costs. These principles guide nearly every decision in space mission engineering\u2014from selecting launch vehicles to trajectory corrections. \u2705 9. Conclusion This report explored the concept of cosmic velocities in gravitational mechanics. We: \u2705 Derived the three cosmic velocities using physical laws. \u2705 Calculated accurate values for Earth. \u2705 Compared velocities for the Moon, Mars, and Jupiter. \u2705 Visualized these values using bar charts. \u2705 Discussed their practical use in space missions. Key Insight : Understanding cosmic velocities is not just theoretical\u2014it is essential to real-world space navigation. These thresholds represent the boundaries between orbital stability, escape, and interstellar potential. As space exploration advances, especially with growing interest in Mars colonization and deep-space travel, mastering these velocities becomes more relevant than ever.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-motivation","text":"The concept of escape velocity is essential to understanding how spacecraft overcome the gravitational pull of celestial bodies. More broadly, physicists define three key thresholds of motion in gravitational fields: First cosmic velocity \u2013 the minimum speed required to maintain a stable circular orbit. Second cosmic velocity \u2013 the minimum speed to break free from a planet\u2019s gravity. Third cosmic velocity \u2013 the minimum speed to escape the gravity of a star system. These thresholds are vital for satellite launches, interplanetary travel, and eventually for leaving the Solar System.","title":"\u2705 1. Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-theoretical-background","text":"","title":"\u2705 2. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-speed","text":"This is the minimum speed required for an object to stay in circular orbit around a body (e.g., a satellite orbiting Earth). It's derived from balancing gravitational and centripetal forces: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\] Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"\ud83d\udd39 First Cosmic Velocity (Orbital Speed)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-speed","text":"This is the minimum speed needed to escape a celestial body\u2019s gravity entirely (ignoring air resistance). It's derived from energy conservation : Total mechanical energy must be zero: \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"\ud83d\udd39 Second Cosmic Velocity (Escape Speed)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape","text":"This is the speed required to escape the gravity of the entire star system , like leaving the Solar System. A spacecraft already in Earth orbit has velocity \\(v_\\text{Earth orbit}\\) around the Sun. We need to increase its total energy to unbind it from the Sun: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r_{\\text{Earth}}}} - v_\\text{Earth orbit} \\] Where: \\(M_{\\odot}\\) is the solar mass, \\(r_{\\text{Earth}}\\) is the orbital radius of Earth, \\(v_\\text{Earth orbit} = \\sqrt{\\frac{G M_{\\odot}}{r}}\\)","title":"\ud83d\udd39 Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-values-for-earth","text":"Given: \\(G = 6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2\\) \\(M_\\text{Earth} = 5.972 \\times 10^{24}\\ \\text{kg}\\) \\(R_\\text{Earth} = 6.371 \\times 10^6\\ \\text{m}\\) \\(M_\\odot = 1.989 \\times 10^{30}\\ \\text{kg}\\) \\(r_\\text{Earth orbit} = 1.496 \\times 10^{11}\\ \\text{m}\\)","title":"\u2705 3. Values for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"\\[ v_1 = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91 \\times 10^3\\ \\text{m/s} = 7.91\\ \\text{km/s} \\]","title":"\u2714 First cosmic velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"\\[ v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.2\\ \\text{km/s} \\]","title":"\u2714 Second cosmic velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Solar orbital speed of Earth: \\[ v_\\text{Earth orbit} = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{1.496 \\times 10^{11}}} \\approx 29.78\\ \\text{km/s} \\] Solar escape speed: \\[ v_\\text{sun,escape} = \\sqrt{2} \\cdot 29.78 \\approx 42.1\\ \\text{km/s} \\] Then: \\[ v_3 = 42.1 - 29.78 \\approx 12.3\\ \\text{km/s} \\]","title":"\u2714 Third cosmic velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-summary-table-cosmic-velocities-for-earth","text":"Velocity Type Value (km/s) First Cosmic ( \\(v_1\\) ) 7.91 Second Cosmic ( \\(v_2\\) ) 11.2 Third Cosmic ( \\(v_3\\) ) 12.3","title":"\u2705 4. Summary Table: Cosmic Velocities for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-comparison-moon-mars-jupiter","text":"Body Mass (kg) Radius (m) \\(v_1\\) (km/s) \\(v_2\\) (km/s) Moon \\(7.35 \\times 10^{22}\\) \\(1.74 \\times 10^6\\) 1.68 2.38 Mars \\(6.42 \\times 10^{23}\\) \\(3.39 \\times 10^6\\) 3.55 5.03 Earth \\(5.97 \\times 10^{24}\\) \\(6.37 \\times 10^6\\) 7.91 11.2 Jupiter \\(1.90 \\times 10^{27}\\) \\(6.99 \\times 10^7\\) 42.1 59.5","title":"\u2705 5. Comparison: Moon, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-python-visualization-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Data bodies = ['Moon', 'Mars', 'Earth', 'Jupiter'] v1 = [1.68, 3.55, 7.91, 42.1] v2 = [2.38, 5.03, 11.2, 59.5] x = np.arange(len(bodies)) width = 0.35 plt.figure(figsize=(8,5)) plt.bar(x - width/2, v1, width, label='First Cosmic Velocity (v\u2081)', color='royalblue') plt.bar(x + width/2, v2, width, label='Second Cosmic Velocity (v\u2082)', color='crimson') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.xticks(x, bodies) plt.legend() plt.grid(True, linestyle='--', alpha=0.4) plt.tight_layout() plt.show()","title":"\u2705 6. Python Visualization: Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colablink","text":"","title":"ColabLink"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-importance-in-space-exploration","text":"Understanding the three cosmic velocities is essential for planning and executing space missions: First Cosmic Velocity ( \\(v_1\\) ) is the speed required to maintain a stable orbit around a celestial body. It is fundamental for launching satellites into low Earth orbit (LEO) and geostationary orbits. Spacecraft like the International Space Station operate at near this speed. Second Cosmic Velocity ( \\(v_2\\) ) is crucial for planetary missions . It allows spacecraft to escape Earth's gravity and travel to the Moon, Mars, or beyond. Missions like Apollo 11, Curiosity rover, and future human missions to Mars rely on achieving this velocity. Third Cosmic Velocity ( \\(v_3\\) ) marks the threshold for interstellar escape . Spacecraft such as Voyager 1 and Voyager 2 reached or exceeded this speed, enabling them to leave the Solar System. Future deep-space missions will use advanced propulsion systems to approach or surpass this velocity. These velocities define not just the energy requirements but also shape mission design, fuel budgets, launch timing, and trajectory planning.","title":"\u2705 7. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#8-applications-and-insights","text":"\ud83d\ude80 Satellite Deployment : Launch vehicles aim to achieve \\(v_1\\) to insert payloads into orbit. Different types of orbits (LEO, MEO, GEO) have slightly different orbital speeds. \ud83c\udf0d Planetary Transfer : To send a probe to Mars or Venus, a spacecraft must achieve \\(v_2\\) to escape Earth\u2019s gravity, and then follow a Hohmann transfer orbit to reach the target. \ud83c\udf0c Interstellar Probes : Voyager 1 and 2 required gravitational assists to reach \\(v_3\\) and leave the Solar System. Future missions, such as the Interstellar Probe Concept , are being designed with these speeds in mind. \u2696\ufe0f Energy Considerations : Each step from \\(v_1\\) to \\(v_3\\) represents an exponential increase in energy. The formula for kinetic energy, \\(E = \\frac{1}{2}mv^2\\) , shows that small increases in speed lead to significantly higher energy costs. These principles guide nearly every decision in space mission engineering\u2014from selecting launch vehicles to trajectory corrections.","title":"\u2705 8. Applications and Insights"},{"location":"1%20Physics/2%20Gravity/Problem_2/#9-conclusion","text":"This report explored the concept of cosmic velocities in gravitational mechanics. We: \u2705 Derived the three cosmic velocities using physical laws. \u2705 Calculated accurate values for Earth. \u2705 Compared velocities for the Moon, Mars, and Jupiter. \u2705 Visualized these values using bar charts. \u2705 Discussed their practical use in space missions. Key Insight : Understanding cosmic velocities is not just theoretical\u2014it is essential to real-world space navigation. These thresholds represent the boundaries between orbital stability, escape, and interstellar potential. As space exploration advances, especially with growing interest in Mars colonization and deep-space travel, mastering these velocities becomes more relevant than ever.","title":"\u2705 9. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth \u2705 1. Motivation Understanding the motion of a payload released from a moving spacecraft is crucial in space exploration. The trajectory it follows depends on the initial velocity, position, and the influence of gravity. This scenario is not only a classical mechanics problem but also relevant for applications such as: Orbital insertion and satellite deployment Reentry trajectories of spacecraft Escape missions or planetary flybys In this report, we analyze and simulate the various types of trajectories\u2014elliptical, parabolic, and hyperbolic\u2014that a payload might follow after release, and visualize their outcomes based on different initial velocities. \u2705 2. Physical Background When a mass is released near a planet, it experiences gravitational acceleration according to Newton's law of universal gravitation: \\[F = \\frac{G M m}{r^2}\\] From this, the gravitational acceleration at distance \\(r\\) is: \\[a = \\frac{F}{m} = \\frac{G M}{r^2}\\] The trajectory depends on the total energy of the payload: Elliptical orbit: \\(E < 0\\) Parabolic escape: \\(E = 0\\) Hyperbolic escape: \\(E > 0\\) Where total energy is given by: \\[E = \\frac{1}{2}mv^2 - \\frac{G M m}{r}\\] And \\(v\\) is the velocity at distance \\(r\\) . \u2705 3. Analytical Conditions for Different Trajectories At a given altitude, the critical velocities determine what kind of trajectory the payload will follow. For Earth, at radius \\(r = R + h\\) , where \\(h\\) is the altitude and \\(R\\) is Earth's radius: Orbital velocity (First cosmic velocity): \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] Escape velocity (Second cosmic velocity): \\[v_2 = \\sqrt{\\frac{2 G M}{r}}\\] Velocity to escape Sun from Earth orbit (Third cosmic velocity, approx): \\[v_3 \\approx \\sqrt{v_2^2 + v_{orbit,sun}^2}\\] We focus here on the first two, since third cosmic velocity is better suited for interplanetary scale. \u2705 4. Initial Conditions Gravitational constant: \\(G = 6.674 \\times 10^{-11}\\ \\text{m}^3/\\text{kg/s}^2\\) Mass of Earth: \\(M = 5.972 \\times 10^{24}\\ \\text{kg}\\) Radius of Earth: \\(R = 6.371 \\times 10^6\\ \\text{m}\\) Altitude: \\(h = 800\\ \\text{km} = 8.0 \\times 10^5\\ \\text{m}\\) Position: \\(r = R + h = 7.171 \\times 10^6\\ \\text{m}\\) Now we calculate the two key velocities at this altitude: \\(v_1 = \\sqrt{\\frac{G M}{r}} \\approx 7.45\\ \\text{km/s}\\) \\(v_2 = \\sqrt{2} \\cdot v_1 \\approx 10.54\\ \\text{km/s}\\) \u2705 5. Simulation of Payload Trajectories We simulate trajectories for a payload released at an altitude of 800 km with initial velocities from 5 km/s to 13 km/s, using numerical integration. \ud83d\udd39 Python Code to Simulate and Plot: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6371e3 # m h = 800e3 # altitude in meters r0 = R_earth + h # initial distance from center of Earth # Time span for simulation t_span = (0, 10000) t_eval = np.linspace(*t_span, 5000) # Gravitational acceleration function def gravity(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Stop integration if the object hits Earth def hit_earth_event(t, y): x, y_pos = y[0], y[1] r = np.sqrt(x**2 + y_pos**2) return r - R_earth hit_earth_event.terminal = True hit_earth_event.direction = -1 # Only trigger when approaching Earth # Initial position x0, y0 = r0, 0 # Velocities from 5 to 13 km/s velocities = np.arange(5e3, 13.5e3, 0.5e3) # Plot fig, ax = plt.subplots(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, color='blue', label='Earth') ax.add_patch(earth) for v0 in velocities: y_init = [x0, y0, 0, v0] sol = solve_ivp(gravity, t_span, y_init, t_eval=t_eval, events=hit_earth_event, rtol=1e-8) x_vals, y_vals = sol.y[0], sol.y[1] ax.plot(x_vals, y_vals, label=f'v\u2080 = {v0/1e3:.1f} km/s') # Plot formatting ax.set_xlim(-3e7, 3e7) ax.set_ylim(-3e7, 3e7) ax.set_aspect('equal') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Trajectories of a Released Payload at 800 km Altitude') ax.legend() plt.grid(True) plt.show() \u2705 6. Numerical Simulation and Visualization We developed a numerical simulation that calculates the trajectories of a payload released 800 km above the Earth's surface, with varying initial velocities ranging from 5 km/s to 13 km/s. The simulation solves the equations of motion under Earth's gravitational influence using time-stepping. Parameters: - Gravitational constant: \\(G = 6.674 \\times 10^{-11}\\ \\text{N m}^2/\\text{kg}^2\\) - Earth's mass: \\(M = 5.972 \\times 10^{24}\\ \\text{kg}\\) - Earth's radius: \\(R_{\\text{Earth}} = 6371\\ \\text{km}\\) - Initial altitude: \\(800\\ \\text{km}\\) - Initial position: \\((R_{\\text{Earth}} + 800\\ \\text{km}, 0)\\) - Initial velocities: 5, 5.5, 6, ..., 13 km/s horizontally. Python Code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R_earth = 6371e3 # radius of Earth in meters # Initial conditions altitude = 800e3 # 800 km altitude initial_pos = np.array([R_earth + altitude, 0]) # starting at (x,0) initial_velocities = np.arange(5e3, 13.5e3, 0.5e3) # velocities from 5 to 13 km/s # Time settings dt = 1 # time step in seconds t_max = 30000 # total simulation time # Create figure fig, ax = plt.subplots(figsize=(10,10)) theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, 'b', alpha=0.5, label='Earth') # Plot trajectories for v0 in initial_velocities: pos = initial_pos.copy() vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(int(t_max/dt)): r = np.linalg.norm(pos) if r < R_earth: break # collision with Earth acc = -G * M * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) ax.plot(x_vals, y_vals, label=f'{v0/1e3:.1f} km/s') # Plot settings ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Trajectories of a Payload Released Near Earth') ax.legend() ax.set_aspect('equal') ax.grid(True) plt.show() Colablink \u2705 7. Analysis of Trajectory Types Depending on the initial velocity: - Below orbital velocity (~7.9 km/s): The object falls back to Earth (suborbital flight). - At orbital velocity (~7.9 km/s): A circular orbit around Earth is established. - Between orbital and escape velocity (~11.2 km/s): An elliptical orbit is created. - At escape velocity (~11.2 km/s): The payload follows a parabolic trajectory , escaping Earth's gravity. - Above escape velocity: A hyperbolic trajectory results, leading to interplanetary or interstellar travel. The simulation clearly visualizes these transitions between different types of motion. \u2705 8. Importance in Space Exploration Understanding and controlling these trajectories is crucial for: - Satellite Deployment: Achieving stable orbits around Earth. - Space Missions: Sending spacecraft to other planets, requiring precise velocities. - Planetary Defense: Predicting and altering asteroid trajectories. - Return Missions: Planning safe reentry paths for crewed and uncrewed spacecraft. - Deep Space Exploration: Launching probes beyond the Solar System. Correct trajectory calculations ensure mission success and safety, optimizing fuel use and minimizing risks. \u2705 9. Conclusion This study examined the possible trajectories of a payload released near Earth, demonstrating how variations in initial velocity drastically influence the resulting path. Using Newton's gravitational law and numerical simulations: - We derived conditions for suborbital, orbital, escape, and hyperbolic motions. - The plots confirmed theoretical predictions visually. - The analysis highlighted the central role of initial velocity and gravitational forces in orbital mechanics. Such investigations are foundational for space exploration, ensuring the accurate deployment of satellites, interplanetary travel, and beyond.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-motivation","text":"Understanding the motion of a payload released from a moving spacecraft is crucial in space exploration. The trajectory it follows depends on the initial velocity, position, and the influence of gravity. This scenario is not only a classical mechanics problem but also relevant for applications such as: Orbital insertion and satellite deployment Reentry trajectories of spacecraft Escape missions or planetary flybys In this report, we analyze and simulate the various types of trajectories\u2014elliptical, parabolic, and hyperbolic\u2014that a payload might follow after release, and visualize their outcomes based on different initial velocities.","title":"\u2705 1. Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-physical-background","text":"When a mass is released near a planet, it experiences gravitational acceleration according to Newton's law of universal gravitation: \\[F = \\frac{G M m}{r^2}\\] From this, the gravitational acceleration at distance \\(r\\) is: \\[a = \\frac{F}{m} = \\frac{G M}{r^2}\\] The trajectory depends on the total energy of the payload: Elliptical orbit: \\(E < 0\\) Parabolic escape: \\(E = 0\\) Hyperbolic escape: \\(E > 0\\) Where total energy is given by: \\[E = \\frac{1}{2}mv^2 - \\frac{G M m}{r}\\] And \\(v\\) is the velocity at distance \\(r\\) .","title":"\u2705 2. Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-analytical-conditions-for-different-trajectories","text":"At a given altitude, the critical velocities determine what kind of trajectory the payload will follow. For Earth, at radius \\(r = R + h\\) , where \\(h\\) is the altitude and \\(R\\) is Earth's radius: Orbital velocity (First cosmic velocity): \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] Escape velocity (Second cosmic velocity): \\[v_2 = \\sqrt{\\frac{2 G M}{r}}\\] Velocity to escape Sun from Earth orbit (Third cosmic velocity, approx): \\[v_3 \\approx \\sqrt{v_2^2 + v_{orbit,sun}^2}\\] We focus here on the first two, since third cosmic velocity is better suited for interplanetary scale.","title":"\u2705 3. Analytical Conditions for Different Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-initial-conditions","text":"Gravitational constant: \\(G = 6.674 \\times 10^{-11}\\ \\text{m}^3/\\text{kg/s}^2\\) Mass of Earth: \\(M = 5.972 \\times 10^{24}\\ \\text{kg}\\) Radius of Earth: \\(R = 6.371 \\times 10^6\\ \\text{m}\\) Altitude: \\(h = 800\\ \\text{km} = 8.0 \\times 10^5\\ \\text{m}\\) Position: \\(r = R + h = 7.171 \\times 10^6\\ \\text{m}\\) Now we calculate the two key velocities at this altitude: \\(v_1 = \\sqrt{\\frac{G M}{r}} \\approx 7.45\\ \\text{km/s}\\) \\(v_2 = \\sqrt{2} \\cdot v_1 \\approx 10.54\\ \\text{km/s}\\)","title":"\u2705 4. Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-simulation-of-payload-trajectories","text":"We simulate trajectories for a payload released at an altitude of 800 km with initial velocities from 5 km/s to 13 km/s, using numerical integration.","title":"\u2705 5. Simulation of Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-to-simulate-and-plot","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6371e3 # m h = 800e3 # altitude in meters r0 = R_earth + h # initial distance from center of Earth # Time span for simulation t_span = (0, 10000) t_eval = np.linspace(*t_span, 5000) # Gravitational acceleration function def gravity(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Stop integration if the object hits Earth def hit_earth_event(t, y): x, y_pos = y[0], y[1] r = np.sqrt(x**2 + y_pos**2) return r - R_earth hit_earth_event.terminal = True hit_earth_event.direction = -1 # Only trigger when approaching Earth # Initial position x0, y0 = r0, 0 # Velocities from 5 to 13 km/s velocities = np.arange(5e3, 13.5e3, 0.5e3) # Plot fig, ax = plt.subplots(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, color='blue', label='Earth') ax.add_patch(earth) for v0 in velocities: y_init = [x0, y0, 0, v0] sol = solve_ivp(gravity, t_span, y_init, t_eval=t_eval, events=hit_earth_event, rtol=1e-8) x_vals, y_vals = sol.y[0], sol.y[1] ax.plot(x_vals, y_vals, label=f'v\u2080 = {v0/1e3:.1f} km/s') # Plot formatting ax.set_xlim(-3e7, 3e7) ax.set_ylim(-3e7, 3e7) ax.set_aspect('equal') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Trajectories of a Released Payload at 800 km Altitude') ax.legend() plt.grid(True) plt.show()","title":"\ud83d\udd39 Python Code to Simulate and Plot:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-numerical-simulation-and-visualization","text":"We developed a numerical simulation that calculates the trajectories of a payload released 800 km above the Earth's surface, with varying initial velocities ranging from 5 km/s to 13 km/s. The simulation solves the equations of motion under Earth's gravitational influence using time-stepping. Parameters: - Gravitational constant: \\(G = 6.674 \\times 10^{-11}\\ \\text{N m}^2/\\text{kg}^2\\) - Earth's mass: \\(M = 5.972 \\times 10^{24}\\ \\text{kg}\\) - Earth's radius: \\(R_{\\text{Earth}} = 6371\\ \\text{km}\\) - Initial altitude: \\(800\\ \\text{km}\\) - Initial position: \\((R_{\\text{Earth}} + 800\\ \\text{km}, 0)\\) - Initial velocities: 5, 5.5, 6, ..., 13 km/s horizontally. Python Code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R_earth = 6371e3 # radius of Earth in meters # Initial conditions altitude = 800e3 # 800 km altitude initial_pos = np.array([R_earth + altitude, 0]) # starting at (x,0) initial_velocities = np.arange(5e3, 13.5e3, 0.5e3) # velocities from 5 to 13 km/s # Time settings dt = 1 # time step in seconds t_max = 30000 # total simulation time # Create figure fig, ax = plt.subplots(figsize=(10,10)) theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, 'b', alpha=0.5, label='Earth') # Plot trajectories for v0 in initial_velocities: pos = initial_pos.copy() vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(int(t_max/dt)): r = np.linalg.norm(pos) if r < R_earth: break # collision with Earth acc = -G * M * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) ax.plot(x_vals, y_vals, label=f'{v0/1e3:.1f} km/s') # Plot settings ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Trajectories of a Payload Released Near Earth') ax.legend() ax.set_aspect('equal') ax.grid(True) plt.show()","title":"\u2705 6. Numerical Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colablink","text":"","title":"Colablink"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-analysis-of-trajectory-types","text":"Depending on the initial velocity: - Below orbital velocity (~7.9 km/s): The object falls back to Earth (suborbital flight). - At orbital velocity (~7.9 km/s): A circular orbit around Earth is established. - Between orbital and escape velocity (~11.2 km/s): An elliptical orbit is created. - At escape velocity (~11.2 km/s): The payload follows a parabolic trajectory , escaping Earth's gravity. - Above escape velocity: A hyperbolic trajectory results, leading to interplanetary or interstellar travel. The simulation clearly visualizes these transitions between different types of motion.","title":"\u2705 7. Analysis of Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#8-importance-in-space-exploration","text":"Understanding and controlling these trajectories is crucial for: - Satellite Deployment: Achieving stable orbits around Earth. - Space Missions: Sending spacecraft to other planets, requiring precise velocities. - Planetary Defense: Predicting and altering asteroid trajectories. - Return Missions: Planning safe reentry paths for crewed and uncrewed spacecraft. - Deep Space Exploration: Launching probes beyond the Solar System. Correct trajectory calculations ensure mission success and safety, optimizing fuel use and minimizing risks.","title":"\u2705 8. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#9-conclusion","text":"This study examined the possible trajectories of a payload released near Earth, demonstrating how variations in initial velocity drastically influence the resulting path. Using Newton's gravitational law and numerical simulations: - We derived conditions for suborbital, orbital, escape, and hyperbolic motions. - The plots confirmed theoretical predictions visually. - The analysis highlighted the central role of initial velocity and gravitational forces in orbital mechanics. Such investigations are foundational for space exploration, ensuring the accurate deployment of satellites, interplanetary travel, and beyond.","title":"\u2705 9. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Waves \u2013 Problem 1 Interference Patterns on a Water Surface 1. Motivation Wave interference occurs when two or more waves meet and overlap. On a water surface, we can clearly see this when circular ripples from different sources interact. These patterns help us understand: Constructive interference : waves reinforce each other (amplitudes add up) Destructive interference : waves cancel out (amplitudes subtract) By exploring different numbers and positions of wave sources, we can visualize these effects. This simulation provides an intuitive way to understand wave superposition using both static and dynamic visualizations. 2. Theory A wave from a point source at \\((x_0, y_0)\\) on a 2D surface can be written as: \\[\\eta(x, y, t) = A \\cos(k r - \\omega t + \\phi), \\quad r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\] Where: - \\(A\\) is the amplitude - \\(k = \\dfrac{2\\pi}{\\lambda}\\) is the wave number - \\(\\omega = 2\\pi f\\) is the angular frequency - \\(\\phi\\) is the phase - \\(r\\) is the distance from the source to the point \\((x, y)\\) For multiple sources, we use the principle of superposition: \\[\\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi)\\] 3. Python Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Wave Parameters A = 1 \u03bb = 2 f = 1 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 # Grid x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Source Geometry def polygon_sources(n, radius=5): angles = np.linspace(0, 2*np.pi, n, endpoint=False) return [(radius*np.cos(a), radius*np.sin(a)) for a in angles] # Total Wave Function def total_wave(X, Y, t, sources): Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - \u03c9 * t + \u03c6) return Z \u2705 4. Static Visualizations \ud83d\udd39 4.1 One Source (Single Circular Wave) \ud83d\udcd8 Explanation: A single point source located at the center generates concentric circular wavefronts. Since there are no other waves to interact with, no interference is present\u2014only pure propagation of the wave. \ud83d\udd39 4.2 Two Sources \ud83d\udcd8 Explanation: Two sources placed symmetrically along the horizontal axis produce a classic interference pattern. The overlapping waves create alternating bands of constructive (bright/red) and destructive (dark/blue) interference. This visualizes wave superposition in its simplest non-trivial form. \ud83d\udd39 4.3 Three Sources (Triangle) \ud83d\udcd8 Explanation: Three coherent sources located at the vertices of an equilateral triangle generate a symmetric, star-like interference pattern. High symmetry in the arrangement leads to multiple points of stable constructive interference and predictable destructive zones. \ud83d\udd39 4.4 Four Sources (Square) \ud83d\udcd8 Explanation: This configuration of four sources at the corners of a square creates a grid-like interference layout. Interference peaks and troughs repeat in both x and y directions, leading to a checkerboard-like intensity structure. \ud83d\udd39 4.5 Five Sources (Pentagon) \ud83d\udcd8 Explanation: Five sources at the vertices of a regular pentagon result in a highly complex and dense interference pattern. Due to fivefold symmetry, wave crests and troughs constructively and destructively interfere in a radial arrangement, showing fine detail and rich structure. \u2705 5. 3D Surface Visualization \ud83d\udcd8 Explanation: The 3D surface shows how amplitude changes over space in a wave system generated by five sources. Peaks represent regions of constructive interference, and valleys represent destructive zones. The z-axis range is extended from -20 to 10 for clarity. This form is helpful to understand not just where interference happens but how strong it is. \u2705 6. Animated Visualization \ud83d\udcd8 Explanation: This animated GIF presents the time evolution of the interference pattern generated by the five-source system. It effectively shows wavefronts propagating, overlapping, and dynamically forming shifting patterns of constructive and destructive interference. Watching the animation provides valuable intuition about how the wave system evolves in time, making it easier to understand phase relationships and motion across the field. import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from matplotlib import cm # Parameters A = 1 # Amplitude \u03bb = 2 # Wavelength f = 1 # Frequency k = 2*np.pi/\u03bb # Wave number \u03c9 = 2*np.pi*f # Angular frequency \u03c6 = 0 # Phase # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Define source positions (triangle, square, pentagon) def polygon_sources(n, radius=5): angles = np.linspace(0, 2*np.pi, n, endpoint=False) return [(radius*np.cos(a), radius*np.sin(a)) for a in angles] # Choose configuration: triangle (3), square (4), pentagon (5) sources = polygon_sources(5) # Change to 3, 4, or 5 # Total wave function def total_wave(X, Y, t, sources): Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k*r - \u03c9*t + \u03c6) return Z # Animation setup fig, ax = plt.subplots(figsize=(6,6)) def animate(frame): ax.clear() Z = total_wave(X, Y, frame*0.2, sources) im = ax.imshow(Z, cmap='seismic', extent=[-10,10,-10,10], origin='lower') ax.set_title(\"Wave Interference Pattern - Frame {}\".format(frame)) ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") return [im] # Save animation as .gif ani = animation.FuncAnimation(fig, animate, frames=60, blit=False) ani.save('wave_interference.gif', writer='pillow', fps=10) plt.close() print(\"\u2705 GIF saved as wave_interference.gif\") Colablink \u2705 7. Conclusion This study illustrates the core principles of wave interference on a water surface using static and animated visualizations. As we increased the number of sources\u2014from 1 to 5\u2014we observed increasingly intricate interference patterns. One source showed no interference. Two sources demonstrated basic superposition effects. Three or more sources revealed symmetrical and complex interference geometries, especially when arranged in regular polygons. 3D and animated views helped to visualize amplitude and wave motion. The patterns studied are directly applicable in understanding sound fields, electromagnetic wave interference, and even quantum mechanical systems.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves-problem-1","text":"","title":"Waves \u2013 Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-motivation","text":"Wave interference occurs when two or more waves meet and overlap. On a water surface, we can clearly see this when circular ripples from different sources interact. These patterns help us understand: Constructive interference : waves reinforce each other (amplitudes add up) Destructive interference : waves cancel out (amplitudes subtract) By exploring different numbers and positions of wave sources, we can visualize these effects. This simulation provides an intuitive way to understand wave superposition using both static and dynamic visualizations.","title":"1. Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-theory","text":"A wave from a point source at \\((x_0, y_0)\\) on a 2D surface can be written as: \\[\\eta(x, y, t) = A \\cos(k r - \\omega t + \\phi), \\quad r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\] Where: - \\(A\\) is the amplitude - \\(k = \\dfrac{2\\pi}{\\lambda}\\) is the wave number - \\(\\omega = 2\\pi f\\) is the angular frequency - \\(\\phi\\) is the phase - \\(r\\) is the distance from the source to the point \\((x, y)\\) For multiple sources, we use the principle of superposition: \\[\\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi)\\]","title":"2. Theory"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Wave Parameters A = 1 \u03bb = 2 f = 1 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 # Grid x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Source Geometry def polygon_sources(n, radius=5): angles = np.linspace(0, 2*np.pi, n, endpoint=False) return [(radius*np.cos(a), radius*np.sin(a)) for a in angles] # Total Wave Function def total_wave(X, Y, t, sources): Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - \u03c9 * t + \u03c6) return Z","title":"3. Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-static-visualizations","text":"","title":"\u2705 4. Static Visualizations"},{"location":"1%20Physics/3%20Waves/Problem_1/#41-one-source-single-circular-wave","text":"\ud83d\udcd8 Explanation: A single point source located at the center generates concentric circular wavefronts. Since there are no other waves to interact with, no interference is present\u2014only pure propagation of the wave.","title":"\ud83d\udd39 4.1 One Source (Single Circular Wave)"},{"location":"1%20Physics/3%20Waves/Problem_1/#42-two-sources","text":"\ud83d\udcd8 Explanation: Two sources placed symmetrically along the horizontal axis produce a classic interference pattern. The overlapping waves create alternating bands of constructive (bright/red) and destructive (dark/blue) interference. This visualizes wave superposition in its simplest non-trivial form.","title":"\ud83d\udd39 4.2 Two Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#43-three-sources-triangle","text":"\ud83d\udcd8 Explanation: Three coherent sources located at the vertices of an equilateral triangle generate a symmetric, star-like interference pattern. High symmetry in the arrangement leads to multiple points of stable constructive interference and predictable destructive zones.","title":"\ud83d\udd39 4.3 Three Sources (Triangle)"},{"location":"1%20Physics/3%20Waves/Problem_1/#44-four-sources-square","text":"\ud83d\udcd8 Explanation: This configuration of four sources at the corners of a square creates a grid-like interference layout. Interference peaks and troughs repeat in both x and y directions, leading to a checkerboard-like intensity structure.","title":"\ud83d\udd39 4.4 Four Sources (Square)"},{"location":"1%20Physics/3%20Waves/Problem_1/#45-five-sources-pentagon","text":"\ud83d\udcd8 Explanation: Five sources at the vertices of a regular pentagon result in a highly complex and dense interference pattern. Due to fivefold symmetry, wave crests and troughs constructively and destructively interfere in a radial arrangement, showing fine detail and rich structure.","title":"\ud83d\udd39 4.5 Five Sources (Pentagon)"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-3d-surface-visualization","text":"\ud83d\udcd8 Explanation: The 3D surface shows how amplitude changes over space in a wave system generated by five sources. Peaks represent regions of constructive interference, and valleys represent destructive zones. The z-axis range is extended from -20 to 10 for clarity. This form is helpful to understand not just where interference happens but how strong it is.","title":"\u2705 5. 3D Surface Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-animated-visualization","text":"\ud83d\udcd8 Explanation: This animated GIF presents the time evolution of the interference pattern generated by the five-source system. It effectively shows wavefronts propagating, overlapping, and dynamically forming shifting patterns of constructive and destructive interference. Watching the animation provides valuable intuition about how the wave system evolves in time, making it easier to understand phase relationships and motion across the field. import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from matplotlib import cm # Parameters A = 1 # Amplitude \u03bb = 2 # Wavelength f = 1 # Frequency k = 2*np.pi/\u03bb # Wave number \u03c9 = 2*np.pi*f # Angular frequency \u03c6 = 0 # Phase # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Define source positions (triangle, square, pentagon) def polygon_sources(n, radius=5): angles = np.linspace(0, 2*np.pi, n, endpoint=False) return [(radius*np.cos(a), radius*np.sin(a)) for a in angles] # Choose configuration: triangle (3), square (4), pentagon (5) sources = polygon_sources(5) # Change to 3, 4, or 5 # Total wave function def total_wave(X, Y, t, sources): Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k*r - \u03c9*t + \u03c6) return Z # Animation setup fig, ax = plt.subplots(figsize=(6,6)) def animate(frame): ax.clear() Z = total_wave(X, Y, frame*0.2, sources) im = ax.imshow(Z, cmap='seismic', extent=[-10,10,-10,10], origin='lower') ax.set_title(\"Wave Interference Pattern - Frame {}\".format(frame)) ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") return [im] # Save animation as .gif ani = animation.FuncAnimation(fig, animate, frames=60, blit=False) ani.save('wave_interference.gif', writer='pillow', fps=10) plt.close() print(\"\u2705 GIF saved as wave_interference.gif\")","title":"\u2705 6. Animated Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#colablink","text":"","title":"Colablink"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-conclusion","text":"This study illustrates the core principles of wave interference on a water surface using static and animated visualizations. As we increased the number of sources\u2014from 1 to 5\u2014we observed increasingly intricate interference patterns. One source showed no interference. Two sources demonstrated basic superposition effects. Three or more sources revealed symmetrical and complex interference geometries, especially when arranged in regular polygons. 3D and animated views helped to visualize amplitude and wave motion. The patterns studied are directly applicable in understanding sound fields, electromagnetic wave interference, and even quantum mechanical systems.","title":"\u2705 7. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 Electromagnetism \u2013 Problem 1 Simulating the Effects of the Lorentz Force \u2705 1. Motivation The Lorentz force is a fundamental concept in electromagnetism that describes how electric and magnetic fields influence the motion of charged particles. This principle governs the operation of: Particle accelerators (e.g., cyclotrons, synchrotrons), Mass spectrometers (used for identifying particles by mass-to-charge ratio), Plasma confinement devices (e.g., tokamaks, magnetic traps), Space physics (charged particle motion in planetary magnetospheres). The Lorentz force is expressed as: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(q\\) is the particle's charge, - \\(\\vec{v}\\) is its velocity, - \\(\\vec{E}\\) is the electric field vector, - \\(\\vec{B}\\) is the magnetic field vector. This force produces circular or helical motion depending on the initial velocity and field configuration. Simulation allows us to visualize these rich dynamics. \u2705 2. Applications of the Lorentz Force \ud83d\udd39 Cyclotron (Particle Accelerators) Charged particles spiral in a magnetic field. This motion is used in circular particle accelerators to increase particle speed. \ud83d\udd39 Mass Spectrometry Charged particles with different mass-to-charge ratios follow distinct paths in known \\(\\vec{E}\\) and \\(\\vec{B}\\) fields. \ud83d\udd39 Plasma Physics The Lorentz force confines and shapes plasma in magnetic traps (e.g., tokamak fusion reactors), enabling fusion reactions. \u2705 3. Theoretical Framework The Newton\u2019s second law for a charged particle in electric and magnetic fields becomes: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Which results in a system of coupled differential equations: \\[ \\frac{d\\vec{r}}{dt} = \\vec{v}, \\quad \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] We assume: - \\(q = 1 \\, \\text{C}\\) - \\(m = 1 \\, \\text{g} = 0.001 \\, \\text{kg}\\) This avoids microscopic electron-scale trajectories and gives us visible, understandable results. \u2705 4. Simulation Scenarios We simulate the motion of a charged particle using the above equations. Numerical integration (Euler or Runge-Kutta) is applied. \ud83d\udfe0 Scenario 1: Uniform Magnetic Field Only \\(\\vec{E} = 0\\) \\(\\vec{B} = B \\hat{z}\\) \ud83d\udccc Expected Motion: A circular trajectory in the plane perpendicular to \\(\\vec{B}\\) . Python Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] \u2014 increased to prevent blow-up dt = 0.001 # smaller time step for better stability steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] # First half-step velocity update (leapfrog) a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): # Full step position update r_next = r[-1] + v_half * dt r.append(r_next) # Compute acceleration at new position (based on velocity) a = lorentz_force(v_half, E, B) / m # Full step velocity update v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) # Store full-step velocity for record return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_spiral = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_spiral, E, B, r0) # 3D Plot of the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() \ud83d\udfe2 Scenario 2: Uniform \\(\\vec{B}\\) Field and Initial Velocity with \\(v_z \\ne 0\\) \\(\\vec{E} = 0\\) \\(\\vec{B} = B \\hat{z}\\) \\(v_0\\) has both x and z components \ud83d\udccc Expected Motion: A helical (spiral) trajectory along the \\(z\\) -axis. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.001 # time step [s] steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_circle = np.array([1.0, 0.0, 0.0]) # Purely perpendicular to B r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_circle, E, B, r0) # 3D Plot (but will look flat in z due to circular xy-plane motion) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Circular Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() \ud83d\udd35 Scenario 3: Crossed Electric and Magnetic Fields \\(\\vec{E} = E \\hat{y}\\) \\(\\vec{B} = B \\hat{z}\\) \ud83d\udccc Expected Motion: A drift of the center of the circular motion. Known as \\(\\vec{E} \\times \\vec{B}\\) drift . Drift velocity: \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.001 # time step [s] steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r), np.array(v) # Fields and initial velocity B = np.array([0, 0, 1]) # Magnetic field along z E = np.array([1, 0, 0]) # Electric field along x v0 = np.array([0.0, 1.0, 0.0]) # Some initial perpendicular velocity # Run simulation positions, velocities = simulate_motion(v0, E, B) # 3D Plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"E \u00d7 B Drift of Charged Particle\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() \ud83d\udd36 Scenario 4: Strong Electric Field Only \\(\\vec{E} \\ne 0\\) \\(\\vec{B} = 0\\) \ud83d\udccc Expected Motion: Uniform acceleration in the direction of \\(\\vec{E}\\) (parabolic path in velocity space). import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.001 # time step [s] steps = 5000 # number of steps # Lorentz force (B is zero here) def lorentz_force(v, E, B): return q * E # cross(v, 0) = 0 # Leapfrog integration (still works fine) def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r), np.array(v) # Strong Electric Field, No Magnetic Field E = np.array([10.0, 0.0, 0.0]) # Strong field along x-axis B = np.array([0.0, 0.0, 0.0]) # No magnetic field v0 = np.array([0.0, 0.0, 0.0]) # Starting at rest r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0, E, B, r0) # Plot trajectory in 3D (but it's linear in x, flat in y and z) import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Motion Under Strong Electric Field Only\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() Colablink \u2705 5. Parameter Exploration We explore the impact of different parameters on the motion: Parameter Meaning Effect \\(B\\) Magnetic field strength Affects radius of circular motion \\(E\\) Electric field strength Controls acceleration/drift \\(q\\) Charge Direction and speed of force \\(m\\) Mass Inertia, affects curvature \\(v_0\\) Initial velocity Affects orbit shape and drift \u2705 6. Key Concepts and Relations \ud83d\udd38 Larmor Radius (Cyclotron Radius) \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] Where \\(v_\\perp\\) is the component of velocity perpendicular to \\(\\vec{B}\\) . This is the radius of the circular motion. \ud83d\udd38 Larmor Frequency \\[ \\omega_L = \\frac{|q| B}{m} \\] This is the angular speed of rotation in a uniform magnetic field. \ud83d\udd38 Drift Velocity \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Even without net force, the particle\u2019s average position drifts due to the presence of perpendicular electric and magnetic fields. \u2705 7. Real-World Relevance These simulated motions reflect real technologies: In cyclotrons , circular motion increases particle energy. In fusion reactors , helical confinement traps plasma. In Earth\u2019s magnetosphere , particles spiral along magnetic field lines and drift due to electric fields. In spacecraft propulsion , electromagnetic forces accelerate charged plasma. \u2705 8. Conclusion In this report, we explored how charged particles move under the Lorentz force in various field configurations. Through visual simulations, we observed: Circular motion in uniform magnetic fields. Spiral (helical) motion with initial vertical velocity. Drift motion in crossed \\(\\vec{E}\\) and \\(\\vec{B}\\) fields. Parabolic acceleration with electric field only. This highlights how the Lorentz force is central to technologies in electromagnetism, from particle physics to astrophysics. The report also emphasized the importance of choosing suitable parameters to model trajectories on human scales.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-problem-1","text":"","title":"\u26a1 Electromagnetism \u2013 Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-motivation","text":"The Lorentz force is a fundamental concept in electromagnetism that describes how electric and magnetic fields influence the motion of charged particles. This principle governs the operation of: Particle accelerators (e.g., cyclotrons, synchrotrons), Mass spectrometers (used for identifying particles by mass-to-charge ratio), Plasma confinement devices (e.g., tokamaks, magnetic traps), Space physics (charged particle motion in planetary magnetospheres). The Lorentz force is expressed as: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(q\\) is the particle's charge, - \\(\\vec{v}\\) is its velocity, - \\(\\vec{E}\\) is the electric field vector, - \\(\\vec{B}\\) is the magnetic field vector. This force produces circular or helical motion depending on the initial velocity and field configuration. Simulation allows us to visualize these rich dynamics.","title":"\u2705 1. Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-applications-of-the-lorentz-force","text":"","title":"\u2705 2. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-particle-accelerators","text":"Charged particles spiral in a magnetic field. This motion is used in circular particle accelerators to increase particle speed.","title":"\ud83d\udd39 Cyclotron (Particle Accelerators)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mass-spectrometry","text":"Charged particles with different mass-to-charge ratios follow distinct paths in known \\(\\vec{E}\\) and \\(\\vec{B}\\) fields.","title":"\ud83d\udd39 Mass Spectrometry"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-physics","text":"The Lorentz force confines and shapes plasma in magnetic traps (e.g., tokamak fusion reactors), enabling fusion reactions.","title":"\ud83d\udd39 Plasma Physics"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-theoretical-framework","text":"The Newton\u2019s second law for a charged particle in electric and magnetic fields becomes: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Which results in a system of coupled differential equations: \\[ \\frac{d\\vec{r}}{dt} = \\vec{v}, \\quad \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] We assume: - \\(q = 1 \\, \\text{C}\\) - \\(m = 1 \\, \\text{g} = 0.001 \\, \\text{kg}\\) This avoids microscopic electron-scale trajectories and gives us visible, understandable results.","title":"\u2705 3. Theoretical Framework"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-simulation-scenarios","text":"We simulate the motion of a charged particle using the above equations. Numerical integration (Euler or Runge-Kutta) is applied.","title":"\u2705 4. Simulation Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-1-uniform-magnetic-field-only","text":"\\(\\vec{E} = 0\\) \\(\\vec{B} = B \\hat{z}\\) \ud83d\udccc Expected Motion: A circular trajectory in the plane perpendicular to \\(\\vec{B}\\) .","title":"\ud83d\udfe0 Scenario 1: Uniform Magnetic Field Only"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] \u2014 increased to prevent blow-up dt = 0.001 # smaller time step for better stability steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] # First half-step velocity update (leapfrog) a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): # Full step position update r_next = r[-1] + v_half * dt r.append(r_next) # Compute acceleration at new position (based on velocity) a = lorentz_force(v_half, E, B) / m # Full step velocity update v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) # Store full-step velocity for record return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_spiral = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_spiral, E, B, r0) # 3D Plot of the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-2-uniform-vecb-field-and-initial-velocity-with-v_z-ne-0","text":"\\(\\vec{E} = 0\\) \\(\\vec{B} = B \\hat{z}\\) \\(v_0\\) has both x and z components \ud83d\udccc Expected Motion: A helical (spiral) trajectory along the \\(z\\) -axis. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.001 # time step [s] steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_circle = np.array([1.0, 0.0, 0.0]) # Purely perpendicular to B r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_circle, E, B, r0) # 3D Plot (but will look flat in z due to circular xy-plane motion) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Circular Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"\ud83d\udfe2 Scenario 2: Uniform \\(\\vec{B}\\) Field and Initial Velocity with \\(v_z \\ne 0\\)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-3-crossed-electric-and-magnetic-fields","text":"\\(\\vec{E} = E \\hat{y}\\) \\(\\vec{B} = B \\hat{z}\\) \ud83d\udccc Expected Motion: A drift of the center of the circular motion. Known as \\(\\vec{E} \\times \\vec{B}\\) drift . Drift velocity: \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.001 # time step [s] steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r), np.array(v) # Fields and initial velocity B = np.array([0, 0, 1]) # Magnetic field along z E = np.array([1, 0, 0]) # Electric field along x v0 = np.array([0.0, 1.0, 0.0]) # Some initial perpendicular velocity # Run simulation positions, velocities = simulate_motion(v0, E, B) # 3D Plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"E \u00d7 B Drift of Charged Particle\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"\ud83d\udd35 Scenario 3: Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-4-strong-electric-field-only","text":"\\(\\vec{E} \\ne 0\\) \\(\\vec{B} = 0\\) \ud83d\udccc Expected Motion: Uniform acceleration in the direction of \\(\\vec{E}\\) (parabolic path in velocity space). import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.001 # time step [s] steps = 5000 # number of steps # Lorentz force (B is zero here) def lorentz_force(v, E, B): return q * E # cross(v, 0) = 0 # Leapfrog integration (still works fine) def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r), np.array(v) # Strong Electric Field, No Magnetic Field E = np.array([10.0, 0.0, 0.0]) # Strong field along x-axis B = np.array([0.0, 0.0, 0.0]) # No magnetic field v0 = np.array([0.0, 0.0, 0.0]) # Starting at rest r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0, E, B, r0) # Plot trajectory in 3D (but it's linear in x, flat in y and z) import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Motion Under Strong Electric Field Only\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"\ud83d\udd36 Scenario 4: Strong Electric Field Only"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#colablink","text":"","title":"Colablink"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-parameter-exploration","text":"We explore the impact of different parameters on the motion: Parameter Meaning Effect \\(B\\) Magnetic field strength Affects radius of circular motion \\(E\\) Electric field strength Controls acceleration/drift \\(q\\) Charge Direction and speed of force \\(m\\) Mass Inertia, affects curvature \\(v_0\\) Initial velocity Affects orbit shape and drift","title":"\u2705 5. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-key-concepts-and-relations","text":"","title":"\u2705 6. Key Concepts and Relations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius-cyclotron-radius","text":"\\[ r_L = \\frac{m v_\\perp}{|q| B} \\] Where \\(v_\\perp\\) is the component of velocity perpendicular to \\(\\vec{B}\\) . This is the radius of the circular motion.","title":"\ud83d\udd38 Larmor Radius (Cyclotron Radius)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-frequency","text":"\\[ \\omega_L = \\frac{|q| B}{m} \\] This is the angular speed of rotation in a uniform magnetic field.","title":"\ud83d\udd38 Larmor Frequency"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#drift-velocity","text":"\\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Even without net force, the particle\u2019s average position drifts due to the presence of perpendicular electric and magnetic fields.","title":"\ud83d\udd38 Drift Velocity"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-real-world-relevance","text":"These simulated motions reflect real technologies: In cyclotrons , circular motion increases particle energy. In fusion reactors , helical confinement traps plasma. In Earth\u2019s magnetosphere , particles spiral along magnetic field lines and drift due to electric fields. In spacecraft propulsion , electromagnetic forces accelerate charged plasma.","title":"\u2705 7. Real-World Relevance"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-conclusion","text":"In this report, we explored how charged particles move under the Lorentz force in various field configurations. Through visual simulations, we observed: Circular motion in uniform magnetic fields. Spiral (helical) motion with initial vertical velocity. Drift motion in crossed \\(\\vec{E}\\) and \\(\\vec{B}\\) fields. Parabolic acceleration with electric field only. This highlights how the Lorentz force is central to technologies in electromagnetism, from particle physics to astrophysics. The report also emphasized the importance of choosing suitable parameters to model trajectories on human scales.","title":"\u2705 8. Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u26a1 Circuits Problem 1 Equivalent Resistance Using Graph Theory \u2705 1. Motivation Calculating equivalent resistance is a key task in circuit analysis. Traditionally, this involves applying series and parallel rules , but for complex resistor networks , these manual methods become inefficient and error-prone. Graph theory provides a powerful alternative. By modeling the circuit as a weighted graph : Nodes represent junctions, Edges represent resistors (weights = resistance), The task becomes a problem of graph simplification. This method allows for algorithmic , repeatable, and programmable solutions \u2014 which are especially useful in circuit simulation software. \u2705 2. Problem Setup We consider a circuit modeled as a graph with: Nodes representing junctions , Edges representing resistors (with resistance values as weights), One START node and one END node. The goal is to find the equivalent resistance between START and END by simplifying the graph using algorithmic steps based on electrical principles. \u2705 3. Theoretical Concepts \ud83d\udd39 Ohm\u2019s Law \\[V = IR\\] \ud83d\udd39 Series Resistance If resistors \\(R_1\\) and \\(R_2\\) are in series : \\[R_{\\text{eq}} = R_1 + R_2\\] \ud83d\udd39 Parallel Resistance If resistors \\(R_1\\) and \\(R_2\\) are in parallel : \\[\\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\] \u2705 4. Graph-Based Strategy We represent the circuit as a graph : - Vertices = junctions - Edges = resistors with weights - Start and end nodes are marked The simplification proceeds by: - Identifying nodes with degree = 2 (series), - Identifying multiple edges between the same nodes (parallel), - Iteratively applying reduction rules until a single edge remains. \u2705 5. Algorithm Overview Step-by-step simplification algorithm: Find nodes with degree 2 (excluding START and END). Apply series rule to combine two adjacent resistors. Find multiple edges between two nodes. Apply parallel rule to combine them. Repeat steps until only one edge connects START to END. \u2705 6. Example: Complex Circuit \ud83d\udd39 Step-by-Step Simplification \u2705 Step 1: Initial Circuit START\u2013A: 2 \u03a9 A\u2013B: 3 \u03a9 A\u2013C: 6 \u03a9 B\u2013C: 4 \u03a9 C\u2013END: 5 \u03a9 B\u2013END: 8 \u03a9 \u2705 Step 2: Combine B\u2013C\u2013END and B\u2013END in Parallel B\u2013C = 4 \u03a9, C\u2013END = 5 \u03a9 \u2192 total series: 4 + 5 = 9 \u03a9 B\u2013END = 8 \u03a9 Combine in parallel: \\[ R_{B-END} = \\left(\\frac{1}{8} + \\frac{1}{9}\\right)^{-1} = \\frac{72}{17} \u2248 4.24\\ \\Omega \\] \u2705 Step 3: Combine A\u2013B\u2013END as Series A\u2013B = 3 \u03a9 B\u2013END (parallel result) = 4.24 \u03a9 Combined: \\[ R_{A\u2013END}^{(1)} = 3 + 4.24 = 7.24\\ \\Omega \\] A\u2013C = 6 \u03a9 C\u2013END = 5 \u03a9 \u2192 A\u2013C\u2013END = 11 \u03a9 \u2705 Step 4: Final Parallel Between A\u2013B\u2013END and A\u2013C\u2013END Parallel of 7.24 \u03a9 and 11 \u03a9: \\[ R_{\\text{A\u2013END}} = \\left(\\frac{1}{7.24} + \\frac{1}{11}\\right)^{-1} = \\frac{79.64}{18.24} \u2248 4.36\\ \\Omega \\] \u2705 Final Equivalent Resistance from START \\[ R_{\\text{eq}} = R_{\\text{START\u2013A}} + R_{\\text{A\u2013END}} = 2 + 4.36 = \\boxed{6.36\\ \\Omega} \\] \u2705 Summary The final equivalent resistance of the circuit is 6.36 \u03a9 Graph theory allows us to visualize and simplify even complex electrical circuits This method can be extended to automated analysis in circuit simulation tools Colablink \u2705 7. Analysis and Efficiency Graph reduction steps are efficient and can be automated. Works for any nested configuration of resistors. Algorithm scales well for larger, complex networks. Complexity: approximately \\[\\mathcal{O}(n \\log n)\\] with efficient detection of patterns. \u2705 8. Conclusion This graph-based method of simplifying resistor networks: Provides a structured and scalable solution, Can be implemented in code for use in circuit simulators , Highlights the deep connection between physics and graph theory . It is especially valuable in modern contexts such as: - PCB design tools, - Educational simulators, - Automated testing and optimization. \ud83d\udccc This approach can be extended to capacitors, AC impedance networks, or even mesh current/loop analysis for complex AC circuits.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits-problem-1","text":"","title":"\u26a1 Circuits Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-motivation","text":"Calculating equivalent resistance is a key task in circuit analysis. Traditionally, this involves applying series and parallel rules , but for complex resistor networks , these manual methods become inefficient and error-prone. Graph theory provides a powerful alternative. By modeling the circuit as a weighted graph : Nodes represent junctions, Edges represent resistors (weights = resistance), The task becomes a problem of graph simplification. This method allows for algorithmic , repeatable, and programmable solutions \u2014 which are especially useful in circuit simulation software.","title":"\u2705 1. Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-problem-setup","text":"We consider a circuit modeled as a graph with: Nodes representing junctions , Edges representing resistors (with resistance values as weights), One START node and one END node. The goal is to find the equivalent resistance between START and END by simplifying the graph using algorithmic steps based on electrical principles.","title":"\u2705 2. Problem Setup"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-theoretical-concepts","text":"","title":"\u2705 3. Theoretical Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#ohms-law","text":"\\[V = IR\\]","title":"\ud83d\udd39 Ohm\u2019s Law"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-resistance","text":"If resistors \\(R_1\\) and \\(R_2\\) are in series : \\[R_{\\text{eq}} = R_1 + R_2\\]","title":"\ud83d\udd39 Series Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistance","text":"If resistors \\(R_1\\) and \\(R_2\\) are in parallel : \\[\\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\]","title":"\ud83d\udd39 Parallel Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-graph-based-strategy","text":"We represent the circuit as a graph : - Vertices = junctions - Edges = resistors with weights - Start and end nodes are marked The simplification proceeds by: - Identifying nodes with degree = 2 (series), - Identifying multiple edges between the same nodes (parallel), - Iteratively applying reduction rules until a single edge remains.","title":"\u2705 4. Graph-Based Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-algorithm-overview","text":"Step-by-step simplification algorithm: Find nodes with degree 2 (excluding START and END). Apply series rule to combine two adjacent resistors. Find multiple edges between two nodes. Apply parallel rule to combine them. Repeat steps until only one edge connects START to END.","title":"\u2705 5. Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-example-complex-circuit","text":"","title":"\u2705 6. Example: Complex Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-simplification","text":"","title":"\ud83d\udd39 Step-by-Step Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-initial-circuit","text":"START\u2013A: 2 \u03a9 A\u2013B: 3 \u03a9 A\u2013C: 6 \u03a9 B\u2013C: 4 \u03a9 C\u2013END: 5 \u03a9 B\u2013END: 8 \u03a9","title":"\u2705 Step 1: Initial Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-combine-bcend-and-bend-in-parallel","text":"B\u2013C = 4 \u03a9, C\u2013END = 5 \u03a9 \u2192 total series: 4 + 5 = 9 \u03a9 B\u2013END = 8 \u03a9 Combine in parallel: \\[ R_{B-END} = \\left(\\frac{1}{8} + \\frac{1}{9}\\right)^{-1} = \\frac{72}{17} \u2248 4.24\\ \\Omega \\]","title":"\u2705 Step 2: Combine B\u2013C\u2013END and B\u2013END in Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-combine-abend-as-series","text":"A\u2013B = 3 \u03a9 B\u2013END (parallel result) = 4.24 \u03a9 Combined: \\[ R_{A\u2013END}^{(1)} = 3 + 4.24 = 7.24\\ \\Omega \\] A\u2013C = 6 \u03a9 C\u2013END = 5 \u03a9 \u2192 A\u2013C\u2013END = 11 \u03a9","title":"\u2705 Step 3: Combine A\u2013B\u2013END as Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-4-final-parallel-between-abend-and-acend","text":"Parallel of 7.24 \u03a9 and 11 \u03a9: \\[ R_{\\text{A\u2013END}} = \\left(\\frac{1}{7.24} + \\frac{1}{11}\\right)^{-1} = \\frac{79.64}{18.24} \u2248 4.36\\ \\Omega \\]","title":"\u2705 Step 4: Final Parallel Between A\u2013B\u2013END and A\u2013C\u2013END"},{"location":"1%20Physics/5%20Circuits/Problem_1/#final-equivalent-resistance-from-start","text":"\\[ R_{\\text{eq}} = R_{\\text{START\u2013A}} + R_{\\text{A\u2013END}} = 2 + 4.36 = \\boxed{6.36\\ \\Omega} \\]","title":"\u2705 Final Equivalent Resistance from START"},{"location":"1%20Physics/5%20Circuits/Problem_1/#summary","text":"The final equivalent resistance of the circuit is 6.36 \u03a9 Graph theory allows us to visualize and simplify even complex electrical circuits This method can be extended to automated analysis in circuit simulation tools","title":"\u2705 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#colablink","text":"","title":"Colablink"},{"location":"1%20Physics/5%20Circuits/Problem_1/#7-analysis-and-efficiency","text":"Graph reduction steps are efficient and can be automated. Works for any nested configuration of resistors. Algorithm scales well for larger, complex networks. Complexity: approximately \\[\\mathcal{O}(n \\log n)\\] with efficient detection of patterns.","title":"\u2705 7. Analysis and Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#8-conclusion","text":"This graph-based method of simplifying resistor networks: Provides a structured and scalable solution, Can be implemented in code for use in circuit simulators , Highlights the deep connection between physics and graph theory . It is especially valuable in modern contexts such as: - PCB design tools, - Educational simulators, - Automated testing and optimization. \ud83d\udccc This approach can be extended to capacitors, AC impedance networks, or even mesh current/loop analysis for complex AC circuits.","title":"\u2705 8. Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Statistics Problem 1 Exploring the Central Limit Theorem (CLT) Through Simulations \u2705 1. Motivation The Central Limit Theorem (CLT) is one of the most important results in probability and statistics. It states: Given a population with any distribution (with finite mean \\(\\mu\\) and variance \\(\\sigma^2\\) ), the sampling distribution of the sample mean approaches a normal distribution as the sample size increases. CLT has powerful implications: - It justifies using the normal distribution in inference, - Enables confidence intervals and hypothesis testing , - Supports statistical modeling across various disciplines. This report demonstrates the CLT via simulations from different types of populations. \u2705 2. Key Definitions Population : The entire set of data values (e.g., all possible outcomes). Sample : A subset taken from the population. Sample mean ( \\(\\bar{x}\\) ) : The average value of a sample. Sampling distribution : The distribution of a statistic (like \\(\\bar{x}\\) ) over many samples. CLT : As sample size \\(n \\to \\infty\\) , the distribution of \\(\\bar{x}\\) approaches normality. \u2705 3. Simulation Plan For each population distribution: 1. Generate a large population (e.g., 100,000 values). 2. Select sample sizes \\(n = 5,\\ 10,\\ 30,\\ 50\\) . 3. Draw repeated random samples from the population. 4. Compute sample means for each iteration. 5. Plot histograms to observe convergence toward a normal shape. Distributions tested: - Uniform \\((0, 1)\\) - Exponential \\((\\lambda=1)\\) - Binomial \\((n=10,\\ p=0.5)\\) \u2705 4. Population Distribution: Uniform(0,1) \ud83c\udfaf Description: Flat distribution from 0 to 1. Mean: \\(\\mu = 0.5\\) Variance: \\(\\sigma^2 = \\frac{1}{12}\\) \ud83e\udde0 Observation : As \\(n\\) increases, histograms become more bell-shaped , approximating a normal distribution. \u2705 5. Population Distribution: Exponential(\u03bb=1) \ud83c\udfaf Description: Skewed distribution, mean = 1 Heavy tail \ud83e\udde0 Observation : Convergence is slower due to high skewness , but normality is still visible as \\(n\\) grows. \u2705 6. Population Distribution: Binomial(n=10, p=0.5) \ud83c\udfaf Description: Discrete, symmetric shape (similar to normal) Mean = \\(np = 5\\) \ud83e\udde0 Observation : Faster convergence due to population already being close to normal . Colablink \u2705 7. Parameter Exploration \ud83d\udd0d Influence of: Sample size ( \\(n\\) ) : Larger \\(n\\) = better approximation to normal Population shape : More skewed \u2192 slower convergence Variance : Affects spread (standard error \\(\\propto \\frac{\\sigma}{\\sqrt{n}}\\) ) \u2705 8. Real-World Applications of CLT Estimating population parameters (e.g., average income, exam scores) Manufacturing : Sample testing and quality control Finance : Risk estimation using historical return sampling Epidemiology : Predicting disease metrics using population sampling CLT enables use of normal-based confidence intervals and p-values in all these fields. \u2705 9. Conclusion The Central Limit Theorem holds for all tested distributions: \u2705 Even when populations are non-normal or skewed \u2705 Larger samples produce normal-like sampling distributions \u2705 Convergence is faster when population is less skewed CLT allows us to use powerful statistical tools regardless of the underlying population.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#statistics-problem-1","text":"","title":"Statistics Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-clt-through-simulations","text":"","title":"Exploring the Central Limit Theorem (CLT) Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-motivation","text":"The Central Limit Theorem (CLT) is one of the most important results in probability and statistics. It states: Given a population with any distribution (with finite mean \\(\\mu\\) and variance \\(\\sigma^2\\) ), the sampling distribution of the sample mean approaches a normal distribution as the sample size increases. CLT has powerful implications: - It justifies using the normal distribution in inference, - Enables confidence intervals and hypothesis testing , - Supports statistical modeling across various disciplines. This report demonstrates the CLT via simulations from different types of populations.","title":"\u2705 1. Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-key-definitions","text":"Population : The entire set of data values (e.g., all possible outcomes). Sample : A subset taken from the population. Sample mean ( \\(\\bar{x}\\) ) : The average value of a sample. Sampling distribution : The distribution of a statistic (like \\(\\bar{x}\\) ) over many samples. CLT : As sample size \\(n \\to \\infty\\) , the distribution of \\(\\bar{x}\\) approaches normality.","title":"\u2705 2. Key Definitions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-simulation-plan","text":"For each population distribution: 1. Generate a large population (e.g., 100,000 values). 2. Select sample sizes \\(n = 5,\\ 10,\\ 30,\\ 50\\) . 3. Draw repeated random samples from the population. 4. Compute sample means for each iteration. 5. Plot histograms to observe convergence toward a normal shape. Distributions tested: - Uniform \\((0, 1)\\) - Exponential \\((\\lambda=1)\\) - Binomial \\((n=10,\\ p=0.5)\\)","title":"\u2705 3. Simulation Plan"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-population-distribution-uniform01","text":"","title":"\u2705 4. Population Distribution: Uniform(0,1)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#description","text":"Flat distribution from 0 to 1. Mean: \\(\\mu = 0.5\\) Variance: \\(\\sigma^2 = \\frac{1}{12}\\) \ud83e\udde0 Observation : As \\(n\\) increases, histograms become more bell-shaped , approximating a normal distribution.","title":"\ud83c\udfaf Description:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-population-distribution-exponential1","text":"","title":"\u2705 5. Population Distribution: Exponential(\u03bb=1)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#description_1","text":"Skewed distribution, mean = 1 Heavy tail \ud83e\udde0 Observation : Convergence is slower due to high skewness , but normality is still visible as \\(n\\) grows.","title":"\ud83c\udfaf Description:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-population-distribution-binomialn10-p05","text":"","title":"\u2705 6. Population Distribution: Binomial(n=10, p=0.5)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#description_2","text":"Discrete, symmetric shape (similar to normal) Mean = \\(np = 5\\) \ud83e\udde0 Observation : Faster convergence due to population already being close to normal .","title":"\ud83c\udfaf Description:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#colablink","text":"","title":"Colablink"},{"location":"1%20Physics/6%20Statistics/Problem_1/#7-parameter-exploration","text":"","title":"\u2705 7. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#influence-of","text":"Sample size ( \\(n\\) ) : Larger \\(n\\) = better approximation to normal Population shape : More skewed \u2192 slower convergence Variance : Affects spread (standard error \\(\\propto \\frac{\\sigma}{\\sqrt{n}}\\) )","title":"\ud83d\udd0d Influence of:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#8-real-world-applications-of-clt","text":"Estimating population parameters (e.g., average income, exam scores) Manufacturing : Sample testing and quality control Finance : Risk estimation using historical return sampling Epidemiology : Predicting disease metrics using population sampling CLT enables use of normal-based confidence intervals and p-values in all these fields.","title":"\u2705 8. Real-World Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#9-conclusion","text":"The Central Limit Theorem holds for all tested distributions: \u2705 Even when populations are non-normal or skewed \u2705 Larger samples produce normal-like sampling distributions \u2705 Convergence is faster when population is less skewed CLT allows us to use powerful statistical tools regardless of the underlying population.","title":"\u2705 9. Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 \ud83d\udcd0 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo methods are widely used in physics, engineering, and finance to simulate random processes. One of the most intuitive and visually appealing applications of this method is estimating the value of \u03c0 \u2014 the ratio of a circle\u2019s circumference to its diameter. In this project, we implement and compare two classic methods for estimating \u03c0: 1. The geometric circle method (area-based approach). 2. The Buffon's needle experiment (probabilistic geometry). These methods reveal the power of randomness and how it can be used to derive accurate approximations for fundamental constants. Part 1: Estimating \u03c0 with Random Points in a Circle 1. Theoretical Background We place a unit circle (radius = 1) inside a square of side 2 (from -1 to 1 in both axes). Random points \\((x, y)\\) are generated within the square. If a point lies within the circle, it satisfies: \\[ x^2 + y^2 \\leq 1 \\] Since the area of the square is \\(4\\) and the area of the unit circle is \\(\\pi\\) , the ratio of points falling inside the circle approximates the ratio of the areas: \\[ \\frac{\\text{Points inside}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\quad \\Rightarrow \\quad \\pi \\approx 4 \\cdot \\frac{\\text{Inside}}{\\text{Total}} \\] This provides a simple way to estimate \u03c0 using only geometry and random numbers. 2. Simulation Process We simulate \\(n\\) random points within the square, count how many fall within the circle, and apply the formula above to estimate \u03c0. Python code to simulate \\(n\\) random points, count how many fall within the unit circle, and estimate \u03c0: import numpy as np def monte_carlo_pi(n_points=10000): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points print(f\"Estimated \u03c0 \u2248 {pi_estimate:.5f} using {n_points} random points\") return pi_estimate # Example use: monte_carlo_pi(10000) 3. Visualization of Points To better understand the process, we visualize: - Green points that fall inside the circle. - Red points that fall outside the circle. This helps illustrate how the method works geometrically and intuitively. 4. Accuracy and Convergence The law of large numbers tells us that the estimate will converge to the true value of \u03c0 as the number of points increases. We observe: - With a small number of points (e.g. 100), the estimate is unstable. - With 10,000+ points, the estimate approaches 3.14 and stabilizes. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Background Buffon's Needle is a classical problem in probability. Imagine a floor with parallel lines spaced distance \\(d\\) apart. A needle of length \\(L \\leq d\\) is dropped randomly. The probability that the needle crosses a line is given by: \\[ P = \\frac{2L}{\\pi d} \\quad \\Rightarrow \\quad \\pi \\approx \\frac{2L \\cdot N}{d \\cdot H} \\] Where: - \\(N\\) = total needle drops - \\(H\\) = number of crossings (hits) - \\(L\\) = needle length - \\(d\\) = line spacing This method connects geometry, probability, and estimation in a surprising and elegant way. 2. Simulation Process We simulate random needle drops: - Randomize the needle center's position between two lines - Randomize the angle - Check if the needle crosses a line import numpy as np def buffon_needle_simulation(n_needles=10000, L=1.0, d=1.0): \"\"\" Simulates Buffon's Needle experiment. Parameters: n_needles (int): Number of needle drops. L (float): Length of the needle. d (float): Distance between parallel lines (must be >= L for the formula to hold). Returns: Estimated value of \u03c0. \"\"\" if L > d: raise ValueError(\"Needle length must be less than or equal to the distance between lines.\") hits = 0 for _ in range(n_needles): x = np.random.uniform(0, d / 2) # Distance from center to nearest line theta = np.random.uniform(0, np.pi / 2) # Angle with respect to the lines if x <= (L / 2) * np.sin(theta): hits += 1 if hits == 0: return float('inf') # Avoid division by zero pi_estimate = (2 * L * n_needles) / (d * hits) print(f\"Estimated \u03c0 \u2248 {pi_estimate:.5f} from {n_needles} needle drops\") return pi_estimate # Example usage: buffon_needle_simulation(n_needles=10000) 3. Visualization of Needle Drops To illustrate: - Blue needles cross a line. - Gray needles do not cross. Parallel lines are shown as vertical dashed lines. \ud83d\udccc Insert Here: Plot showing needle drops and line crossings. Title includes total drops, hits, and estimated \u03c0. This makes the geometric probability visible and understandable. 4. Convergence and Comparison As the number of needle drops increases, the estimate of \u03c0 improves, although more slowly than with the circle method. Colablink We compare: - Convergence rate - Variance in estimates - Sensitivity to sample size \ud83d\udcca Summary Table Method Estimate Formula Speed of Convergence Accuracy (n=10,000) Notes Circle Method \\(\u03c0 \u2248 4 \\cdot \\frac{M}{N}\\) Faster \u00b10.01\u20130.03 Simple, visual, low variance Buffon's Needle \\(\u03c0 \u2248 \\frac{2L \\cdot N}{d \\cdot H}\\) Slower \u00b10.05\u20130.1 Historical, higher variability Where: - \\(M\\) = number of points inside the circle - \\(N\\) = total number of points - \\(H\\) = number of hits (needle crosses a line) \u2705 Conclusion This project demonstrates the power and versatility of Monte Carlo methods: The Circle Method provides a fast and visual estimation of \u03c0 with good accuracy and simple implementation. Buffon\u2019s Needle offers a beautiful probabilistic approach rooted in classical mathematics but converges more slowly and shows more variation. Both highlight how randomness, geometry, and probability come together in computational simulations. These experiments build a deeper understanding of convergence, estimation, and the connection between mathematics and real-world simulation.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"\ud83d\udcd0 Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo methods are widely used in physics, engineering, and finance to simulate random processes. One of the most intuitive and visually appealing applications of this method is estimating the value of \u03c0 \u2014 the ratio of a circle\u2019s circumference to its diameter. In this project, we implement and compare two classic methods for estimating \u03c0: 1. The geometric circle method (area-based approach). 2. The Buffon's needle experiment (probabilistic geometry). These methods reveal the power of randomness and how it can be used to derive accurate approximations for fundamental constants.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-with-random-points-in-a-circle","text":"","title":"Part 1: Estimating \u03c0 with Random Points in a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-background","text":"We place a unit circle (radius = 1) inside a square of side 2 (from -1 to 1 in both axes). Random points \\((x, y)\\) are generated within the square. If a point lies within the circle, it satisfies: \\[ x^2 + y^2 \\leq 1 \\] Since the area of the square is \\(4\\) and the area of the unit circle is \\(\\pi\\) , the ratio of points falling inside the circle approximates the ratio of the areas: \\[ \\frac{\\text{Points inside}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\quad \\Rightarrow \\quad \\pi \\approx 4 \\cdot \\frac{\\text{Inside}}{\\text{Total}} \\] This provides a simple way to estimate \u03c0 using only geometry and random numbers.","title":"1. Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-process","text":"We simulate \\(n\\) random points within the square, count how many fall within the circle, and apply the formula above to estimate \u03c0. Python code to simulate \\(n\\) random points, count how many fall within the unit circle, and estimate \u03c0: import numpy as np def monte_carlo_pi(n_points=10000): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points print(f\"Estimated \u03c0 \u2248 {pi_estimate:.5f} using {n_points} random points\") return pi_estimate # Example use: monte_carlo_pi(10000)","title":"2. Simulation Process"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization-of-points","text":"To better understand the process, we visualize: - Green points that fall inside the circle. - Red points that fall outside the circle. This helps illustrate how the method works geometrically and intuitively.","title":"3. Visualization of Points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-accuracy-and-convergence","text":"The law of large numbers tells us that the estimate will converge to the true value of \u03c0 as the number of points increases. We observe: - With a small number of points (e.g. 100), the estimate is unstable. - With 10,000+ points, the estimate approaches 3.14 and stabilizes.","title":"4. Accuracy and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-background_1","text":"Buffon's Needle is a classical problem in probability. Imagine a floor with parallel lines spaced distance \\(d\\) apart. A needle of length \\(L \\leq d\\) is dropped randomly. The probability that the needle crosses a line is given by: \\[ P = \\frac{2L}{\\pi d} \\quad \\Rightarrow \\quad \\pi \\approx \\frac{2L \\cdot N}{d \\cdot H} \\] Where: - \\(N\\) = total needle drops - \\(H\\) = number of crossings (hits) - \\(L\\) = needle length - \\(d\\) = line spacing This method connects geometry, probability, and estimation in a surprising and elegant way.","title":"1. Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-process_1","text":"We simulate random needle drops: - Randomize the needle center's position between two lines - Randomize the angle - Check if the needle crosses a line import numpy as np def buffon_needle_simulation(n_needles=10000, L=1.0, d=1.0): \"\"\" Simulates Buffon's Needle experiment. Parameters: n_needles (int): Number of needle drops. L (float): Length of the needle. d (float): Distance between parallel lines (must be >= L for the formula to hold). Returns: Estimated value of \u03c0. \"\"\" if L > d: raise ValueError(\"Needle length must be less than or equal to the distance between lines.\") hits = 0 for _ in range(n_needles): x = np.random.uniform(0, d / 2) # Distance from center to nearest line theta = np.random.uniform(0, np.pi / 2) # Angle with respect to the lines if x <= (L / 2) * np.sin(theta): hits += 1 if hits == 0: return float('inf') # Avoid division by zero pi_estimate = (2 * L * n_needles) / (d * hits) print(f\"Estimated \u03c0 \u2248 {pi_estimate:.5f} from {n_needles} needle drops\") return pi_estimate # Example usage: buffon_needle_simulation(n_needles=10000)","title":"2. Simulation Process"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization-of-needle-drops","text":"To illustrate: - Blue needles cross a line. - Gray needles do not cross. Parallel lines are shown as vertical dashed lines. \ud83d\udccc Insert Here: Plot showing needle drops and line crossings. Title includes total drops, hits, and estimated \u03c0. This makes the geometric probability visible and understandable.","title":"3. Visualization of Needle Drops"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-convergence-and-comparison","text":"As the number of needle drops increases, the estimate of \u03c0 improves, although more slowly than with the circle method.","title":"4. Convergence and Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#colablink","text":"We compare: - Convergence rate - Variance in estimates - Sensitivity to sample size","title":"Colablink"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-table","text":"Method Estimate Formula Speed of Convergence Accuracy (n=10,000) Notes Circle Method \\(\u03c0 \u2248 4 \\cdot \\frac{M}{N}\\) Faster \u00b10.01\u20130.03 Simple, visual, low variance Buffon's Needle \\(\u03c0 \u2248 \\frac{2L \\cdot N}{d \\cdot H}\\) Slower \u00b10.05\u20130.1 Historical, higher variability Where: - \\(M\\) = number of points inside the circle - \\(N\\) = total number of points - \\(H\\) = number of hits (needle crosses a line)","title":"\ud83d\udcca Summary Table"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"This project demonstrates the power and versatility of Monte Carlo methods: The Circle Method provides a fast and visual estimation of \u03c0 with good accuracy and simple implementation. Buffon\u2019s Needle offers a beautiful probabilistic approach rooted in classical mathematics but converges more slowly and shows more variation. Both highlight how randomness, geometry, and probability come together in computational simulations. These experiments build a deeper understanding of convergence, estimation, and the connection between mathematics and real-world simulation.","title":"\u2705 Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration Using a Pendulum Objective To determine the acceleration due to gravity \\(g\\) by measuring the oscillation period of a simple pendulum and analyzing uncertainties in measurement. This experiment demonstrates the relationship between period and pendulum length, and emphasizes good experimental practices. Background Theory The motion of a simple pendulum can be described (for small angles \\(\\theta < 15^\\circ\\) ) by the equation: \\[T = 2\\pi \\sqrt{\\frac{L}{g}}\\] Where: - \\(T\\) is the period of one oscillation (in seconds), - \\(L\\) is the length of the pendulum (in meters), - \\(g\\) is the acceleration due to gravity (in m/s\u00b2). By rearranging, we can solve for \\(g\\) : \\[g = \\frac{4\\pi^2 L}{T^2}\\] Apparatus and Materials String (approx. 1.02 meters long) Small weight (e.g., metal keychain) Ruler with 1 mm resolution Stopwatch or phone timer Support stand or hook to suspend the pendulum Procedure 1. Setup Attach the weight securely to one end of the string. Measure the total pendulum length \\(L\\) from the suspension point to the center of mass of the weight. Record: \\(L = 102\\ \\text{cm} = 1.02\\ \\text{m}\\) Ruler resolution = \\(1\\ \\text{mm} = 0.001\\ \\text{m}\\) Uncertainty in length: \\[\\Delta L = \\frac{0.001}{2} = 0.0005\\ \\text{m}\\] 2. Data Collection Displace the pendulum by less than \\(15^\\circ\\) and release it gently. Measure the time for 10 full oscillations ( \\(T_{10}\\) ). Repeat this 10 times: Measurement \\(T_{10}\\) (s) 1 19.42 2 19.25 3 18.78 4 18.58 5 18.95 6 19.50 7 19.43 8 19.62 9 19.93 10 19.43 The following plot shows the time measurements for 10 full oscillations ( \\(T_{10}\\) ): Calculate: Mean time \\(\\overline{T_{10}} = 19.289\\ \\text{s}\\) Standard deviation \\(\\sigma_T = 0.0408\\ \\text{s}\\) Uncertainty in mean: \\[\\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.0129\\ \\text{s}\\] Colablink Calculations 1. Period of One Oscillation \\[T = \\frac{\\overline{T_{10}}}{10} = 1.9289\\ \\text{s}\\] \\[\\Delta T = \\frac{\\Delta T_{10}}{10} = 0.01291\\ \\text{s}\\] 2. Gravitational Acceleration \\[g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\pi^2 \\cdot 1.02}{(1.9289)^2} = 10.82\\ \\text{m/s}^2\\] 3. Uncertainty Propagation \\[\\Delta g = g \\cdot \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\cdot\\frac{\\Delta T}{T}\\right)^2}\\] \\[\\Delta g = 10.82 \\cdot \\sqrt{\\left(\\frac{0.0005}{1.02}\\right)^2 + \\left(2\\cdot\\frac{0.01291}{1.9289}\\right)^2} = 0.15\\ \\text{m/s}^2\\] Final Result \\[g = 10.82 \\pm 0.15\\ \\text{m/s}^2\\] Analysis 1. Comparison with Accepted Value The standard gravitational acceleration on Earth's surface is: \\[g_{\\text{standard}} = 9.81\\ \\text{m/s}^2\\] Our measured value is about 10.3% higher . This deviation may be due to: Errors in time measurement (human reaction delay) Slightly incorrect length measurement Pendulum not swinging in a perfectly vertical plane 2. Discussion of Uncertainties Length measurement uncertainty ( \\(\\Delta L\\) ) : Small but still contributes. Timing variability ( \\(\\sigma_T\\) ) : Affects \\(\\Delta T\\) significantly. Environmental factors : Air resistance and support motion. Assumptions : The angle is small; the string is massless and taut. Conclusion This experiment successfully measured gravitational acceleration with reasonable precision using a simple pendulum. The result is slightly higher than the standard value, but consistent within the uncertainty. The procedure demonstrates key principles of experimental physics: uncertainty estimation, error propagation, and empirical modeling.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-using-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"To determine the acceleration due to gravity \\(g\\) by measuring the oscillation period of a simple pendulum and analyzing uncertainties in measurement. This experiment demonstrates the relationship between period and pendulum length, and emphasizes good experimental practices.","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#background-theory","text":"The motion of a simple pendulum can be described (for small angles \\(\\theta < 15^\\circ\\) ) by the equation: \\[T = 2\\pi \\sqrt{\\frac{L}{g}}\\] Where: - \\(T\\) is the period of one oscillation (in seconds), - \\(L\\) is the length of the pendulum (in meters), - \\(g\\) is the acceleration due to gravity (in m/s\u00b2). By rearranging, we can solve for \\(g\\) : \\[g = \\frac{4\\pi^2 L}{T^2}\\]","title":"Background Theory"},{"location":"1%20Physics/7%20Measurements/Problem_1/#apparatus-and-materials","text":"String (approx. 1.02 meters long) Small weight (e.g., metal keychain) Ruler with 1 mm resolution Stopwatch or phone timer Support stand or hook to suspend the pendulum","title":"Apparatus and Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-setup","text":"Attach the weight securely to one end of the string. Measure the total pendulum length \\(L\\) from the suspension point to the center of mass of the weight. Record: \\(L = 102\\ \\text{cm} = 1.02\\ \\text{m}\\) Ruler resolution = \\(1\\ \\text{mm} = 0.001\\ \\text{m}\\) Uncertainty in length: \\[\\Delta L = \\frac{0.001}{2} = 0.0005\\ \\text{m}\\]","title":"1. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-data-collection","text":"Displace the pendulum by less than \\(15^\\circ\\) and release it gently. Measure the time for 10 full oscillations ( \\(T_{10}\\) ). Repeat this 10 times: Measurement \\(T_{10}\\) (s) 1 19.42 2 19.25 3 18.78 4 18.58 5 18.95 6 19.50 7 19.43 8 19.62 9 19.93 10 19.43 The following plot shows the time measurements for 10 full oscillations ( \\(T_{10}\\) ): Calculate: Mean time \\(\\overline{T_{10}} = 19.289\\ \\text{s}\\) Standard deviation \\(\\sigma_T = 0.0408\\ \\text{s}\\) Uncertainty in mean: \\[\\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.0129\\ \\text{s}\\]","title":"2. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#colablink","text":"","title":"Colablink"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-of-one-oscillation","text":"\\[T = \\frac{\\overline{T_{10}}}{10} = 1.9289\\ \\text{s}\\] \\[\\Delta T = \\frac{\\Delta T_{10}}{10} = 0.01291\\ \\text{s}\\]","title":"1. Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-gravitational-acceleration","text":"\\[g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\pi^2 \\cdot 1.02}{(1.9289)^2} = 10.82\\ \\text{m/s}^2\\]","title":"2. Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-propagation","text":"\\[\\Delta g = g \\cdot \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\cdot\\frac{\\Delta T}{T}\\right)^2}\\] \\[\\Delta g = 10.82 \\cdot \\sqrt{\\left(\\frac{0.0005}{1.02}\\right)^2 + \\left(2\\cdot\\frac{0.01291}{1.9289}\\right)^2} = 0.15\\ \\text{m/s}^2\\]","title":"3. Uncertainty Propagation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\[g = 10.82 \\pm 0.15\\ \\text{m/s}^2\\]","title":"Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison-with-accepted-value","text":"The standard gravitational acceleration on Earth's surface is: \\[g_{\\text{standard}} = 9.81\\ \\text{m/s}^2\\] Our measured value is about 10.3% higher . This deviation may be due to: Errors in time measurement (human reaction delay) Slightly incorrect length measurement Pendulum not swinging in a perfectly vertical plane","title":"1. Comparison with Accepted Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion-of-uncertainties","text":"Length measurement uncertainty ( \\(\\Delta L\\) ) : Small but still contributes. Timing variability ( \\(\\sigma_T\\) ) : Affects \\(\\Delta T\\) significantly. Environmental factors : Air resistance and support motion. Assumptions : The angle is small; the string is massless and taut.","title":"2. Discussion of Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This experiment successfully measured gravitational acceleration with reasonable precision using a simple pendulum. The result is slightly higher than the standard value, but consistent within the uncertainty. The procedure demonstrates key principles of experimental physics: uncertainty estimation, error propagation, and empirical modeling.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}